package requestsfetcher

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/logicrunner/transcript"
)

// BrokerMock implements Broker
type BrokerMock struct {
	t minimock.Tester

	funcAddRequestsFromLedger          func(ctx context.Context, transcripts ...*transcript.Transcript)
	inspectFuncAddRequestsFromLedger   func(ctx context.Context, transcripts ...*transcript.Transcript)
	afterAddRequestsFromLedgerCounter  uint64
	beforeAddRequestsFromLedgerCounter uint64
	AddRequestsFromLedgerMock          mBrokerMockAddRequestsFromLedger

	funcIsKnownRequest          func(ctx context.Context, reqRef insolar.Reference) (b1 bool)
	inspectFuncIsKnownRequest   func(ctx context.Context, reqRef insolar.Reference)
	afterIsKnownRequestCounter  uint64
	beforeIsKnownRequestCounter uint64
	IsKnownRequestMock          mBrokerMockIsKnownRequest

	funcNoMoreRequestsOnLedger          func(ctx context.Context)
	inspectFuncNoMoreRequestsOnLedger   func(ctx context.Context)
	afterNoMoreRequestsOnLedgerCounter  uint64
	beforeNoMoreRequestsOnLedgerCounter uint64
	NoMoreRequestsOnLedgerMock          mBrokerMockNoMoreRequestsOnLedger
}

// NewBrokerMock returns a mock for Broker
func NewBrokerMock(t minimock.Tester) *BrokerMock {
	m := &BrokerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddRequestsFromLedgerMock = mBrokerMockAddRequestsFromLedger{mock: m}
	m.AddRequestsFromLedgerMock.callArgs = []*BrokerMockAddRequestsFromLedgerParams{}

	m.IsKnownRequestMock = mBrokerMockIsKnownRequest{mock: m}
	m.IsKnownRequestMock.callArgs = []*BrokerMockIsKnownRequestParams{}

	m.NoMoreRequestsOnLedgerMock = mBrokerMockNoMoreRequestsOnLedger{mock: m}
	m.NoMoreRequestsOnLedgerMock.callArgs = []*BrokerMockNoMoreRequestsOnLedgerParams{}

	return m
}

type mBrokerMockAddRequestsFromLedger struct {
	mock               *BrokerMock
	defaultExpectation *BrokerMockAddRequestsFromLedgerExpectation
	expectations       []*BrokerMockAddRequestsFromLedgerExpectation

	callArgs []*BrokerMockAddRequestsFromLedgerParams
	mutex    sync.RWMutex
}

// BrokerMockAddRequestsFromLedgerExpectation specifies expectation struct of the Broker.AddRequestsFromLedger
type BrokerMockAddRequestsFromLedgerExpectation struct {
	mock   *BrokerMock
	params *BrokerMockAddRequestsFromLedgerParams

	Counter uint64
}

// BrokerMockAddRequestsFromLedgerParams contains parameters of the Broker.AddRequestsFromLedger
type BrokerMockAddRequestsFromLedgerParams struct {
	ctx         context.Context
	transcripts []*transcript.Transcript
}

// Expect sets up expected params for Broker.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mBrokerMockAddRequestsFromLedger) Expect(ctx context.Context, transcripts ...*transcript.Transcript) *mBrokerMockAddRequestsFromLedger {
	if mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("BrokerMock.AddRequestsFromLedger mock is already set by Set")
	}

	if mmAddRequestsFromLedger.defaultExpectation == nil {
		mmAddRequestsFromLedger.defaultExpectation = &BrokerMockAddRequestsFromLedgerExpectation{}
	}

	mmAddRequestsFromLedger.defaultExpectation.params = &BrokerMockAddRequestsFromLedgerParams{ctx, transcripts}
	for _, e := range mmAddRequestsFromLedger.expectations {
		if minimock.Equal(e.params, mmAddRequestsFromLedger.defaultExpectation.params) {
			mmAddRequestsFromLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRequestsFromLedger.defaultExpectation.params)
		}
	}

	return mmAddRequestsFromLedger
}

// Inspect accepts an inspector function that has same arguments as the Broker.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mBrokerMockAddRequestsFromLedger) Inspect(f func(ctx context.Context, transcripts ...*transcript.Transcript)) *mBrokerMockAddRequestsFromLedger {
	if mmAddRequestsFromLedger.mock.inspectFuncAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("Inspect function is already set for BrokerMock.AddRequestsFromLedger")
	}

	mmAddRequestsFromLedger.mock.inspectFuncAddRequestsFromLedger = f

	return mmAddRequestsFromLedger
}

// Return sets up results that will be returned by Broker.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mBrokerMockAddRequestsFromLedger) Return() *BrokerMock {
	if mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("BrokerMock.AddRequestsFromLedger mock is already set by Set")
	}

	if mmAddRequestsFromLedger.defaultExpectation == nil {
		mmAddRequestsFromLedger.defaultExpectation = &BrokerMockAddRequestsFromLedgerExpectation{mock: mmAddRequestsFromLedger.mock}
	}

	return mmAddRequestsFromLedger.mock
}

//Set uses given function f to mock the Broker.AddRequestsFromLedger method
func (mmAddRequestsFromLedger *mBrokerMockAddRequestsFromLedger) Set(f func(ctx context.Context, transcripts ...*transcript.Transcript)) *BrokerMock {
	if mmAddRequestsFromLedger.defaultExpectation != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("Default expectation is already set for the Broker.AddRequestsFromLedger method")
	}

	if len(mmAddRequestsFromLedger.expectations) > 0 {
		mmAddRequestsFromLedger.mock.t.Fatalf("Some expectations are already set for the Broker.AddRequestsFromLedger method")
	}

	mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger = f
	return mmAddRequestsFromLedger.mock
}

// AddRequestsFromLedger implements Broker
func (mmAddRequestsFromLedger *BrokerMock) AddRequestsFromLedger(ctx context.Context, transcripts ...*transcript.Transcript) {
	mm_atomic.AddUint64(&mmAddRequestsFromLedger.beforeAddRequestsFromLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRequestsFromLedger.afterAddRequestsFromLedgerCounter, 1)

	if mmAddRequestsFromLedger.inspectFuncAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.inspectFuncAddRequestsFromLedger(ctx, transcripts...)
	}

	params := &BrokerMockAddRequestsFromLedgerParams{ctx, transcripts}

	// Record call args
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.mutex.Lock()
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.callArgs = append(mmAddRequestsFromLedger.AddRequestsFromLedgerMock.callArgs, params)
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.mutex.Unlock()

	for _, e := range mmAddRequestsFromLedger.AddRequestsFromLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation.Counter, 1)
		want := mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation.params
		got := BrokerMockAddRequestsFromLedgerParams{ctx, transcripts}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddRequestsFromLedger.t.Errorf("BrokerMock.AddRequestsFromLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddRequestsFromLedger.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.funcAddRequestsFromLedger(ctx, transcripts...)
		return
	}
	mmAddRequestsFromLedger.t.Fatalf("Unexpected call to BrokerMock.AddRequestsFromLedger. %v %v", ctx, transcripts)

}

// AddRequestsFromLedgerAfterCounter returns a count of finished BrokerMock.AddRequestsFromLedger invocations
func (mmAddRequestsFromLedger *BrokerMock) AddRequestsFromLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromLedger.afterAddRequestsFromLedgerCounter)
}

// AddRequestsFromLedgerBeforeCounter returns a count of BrokerMock.AddRequestsFromLedger invocations
func (mmAddRequestsFromLedger *BrokerMock) AddRequestsFromLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromLedger.beforeAddRequestsFromLedgerCounter)
}

// Calls returns a list of arguments used in each call to BrokerMock.AddRequestsFromLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRequestsFromLedger *mBrokerMockAddRequestsFromLedger) Calls() []*BrokerMockAddRequestsFromLedgerParams {
	mmAddRequestsFromLedger.mutex.RLock()

	argCopy := make([]*BrokerMockAddRequestsFromLedgerParams, len(mmAddRequestsFromLedger.callArgs))
	copy(argCopy, mmAddRequestsFromLedger.callArgs)

	mmAddRequestsFromLedger.mutex.RUnlock()

	return argCopy
}

// MinimockAddRequestsFromLedgerDone returns true if the count of the AddRequestsFromLedger invocations corresponds
// the number of defined expectations
func (m *BrokerMock) MinimockAddRequestsFromLedgerDone() bool {
	for _, e := range m.AddRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddRequestsFromLedgerInspect logs each unmet expectation
func (m *BrokerMock) MinimockAddRequestsFromLedgerInspect() {
	for _, e := range m.AddRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerMock.AddRequestsFromLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		if m.AddRequestsFromLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerMock.AddRequestsFromLedger")
		} else {
			m.t.Errorf("Expected call to BrokerMock.AddRequestsFromLedger with params: %#v", *m.AddRequestsFromLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		m.t.Error("Expected call to BrokerMock.AddRequestsFromLedger")
	}
}

type mBrokerMockIsKnownRequest struct {
	mock               *BrokerMock
	defaultExpectation *BrokerMockIsKnownRequestExpectation
	expectations       []*BrokerMockIsKnownRequestExpectation

	callArgs []*BrokerMockIsKnownRequestParams
	mutex    sync.RWMutex
}

// BrokerMockIsKnownRequestExpectation specifies expectation struct of the Broker.IsKnownRequest
type BrokerMockIsKnownRequestExpectation struct {
	mock    *BrokerMock
	params  *BrokerMockIsKnownRequestParams
	results *BrokerMockIsKnownRequestResults
	Counter uint64
}

// BrokerMockIsKnownRequestParams contains parameters of the Broker.IsKnownRequest
type BrokerMockIsKnownRequestParams struct {
	ctx    context.Context
	reqRef insolar.Reference
}

// BrokerMockIsKnownRequestResults contains results of the Broker.IsKnownRequest
type BrokerMockIsKnownRequestResults struct {
	b1 bool
}

// Expect sets up expected params for Broker.IsKnownRequest
func (mmIsKnownRequest *mBrokerMockIsKnownRequest) Expect(ctx context.Context, reqRef insolar.Reference) *mBrokerMockIsKnownRequest {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("BrokerMock.IsKnownRequest mock is already set by Set")
	}

	if mmIsKnownRequest.defaultExpectation == nil {
		mmIsKnownRequest.defaultExpectation = &BrokerMockIsKnownRequestExpectation{}
	}

	mmIsKnownRequest.defaultExpectation.params = &BrokerMockIsKnownRequestParams{ctx, reqRef}
	for _, e := range mmIsKnownRequest.expectations {
		if minimock.Equal(e.params, mmIsKnownRequest.defaultExpectation.params) {
			mmIsKnownRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsKnownRequest.defaultExpectation.params)
		}
	}

	return mmIsKnownRequest
}

// Inspect accepts an inspector function that has same arguments as the Broker.IsKnownRequest
func (mmIsKnownRequest *mBrokerMockIsKnownRequest) Inspect(f func(ctx context.Context, reqRef insolar.Reference)) *mBrokerMockIsKnownRequest {
	if mmIsKnownRequest.mock.inspectFuncIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("Inspect function is already set for BrokerMock.IsKnownRequest")
	}

	mmIsKnownRequest.mock.inspectFuncIsKnownRequest = f

	return mmIsKnownRequest
}

// Return sets up results that will be returned by Broker.IsKnownRequest
func (mmIsKnownRequest *mBrokerMockIsKnownRequest) Return(b1 bool) *BrokerMock {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("BrokerMock.IsKnownRequest mock is already set by Set")
	}

	if mmIsKnownRequest.defaultExpectation == nil {
		mmIsKnownRequest.defaultExpectation = &BrokerMockIsKnownRequestExpectation{mock: mmIsKnownRequest.mock}
	}
	mmIsKnownRequest.defaultExpectation.results = &BrokerMockIsKnownRequestResults{b1}
	return mmIsKnownRequest.mock
}

//Set uses given function f to mock the Broker.IsKnownRequest method
func (mmIsKnownRequest *mBrokerMockIsKnownRequest) Set(f func(ctx context.Context, reqRef insolar.Reference) (b1 bool)) *BrokerMock {
	if mmIsKnownRequest.defaultExpectation != nil {
		mmIsKnownRequest.mock.t.Fatalf("Default expectation is already set for the Broker.IsKnownRequest method")
	}

	if len(mmIsKnownRequest.expectations) > 0 {
		mmIsKnownRequest.mock.t.Fatalf("Some expectations are already set for the Broker.IsKnownRequest method")
	}

	mmIsKnownRequest.mock.funcIsKnownRequest = f
	return mmIsKnownRequest.mock
}

// When sets expectation for the Broker.IsKnownRequest which will trigger the result defined by the following
// Then helper
func (mmIsKnownRequest *mBrokerMockIsKnownRequest) When(ctx context.Context, reqRef insolar.Reference) *BrokerMockIsKnownRequestExpectation {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("BrokerMock.IsKnownRequest mock is already set by Set")
	}

	expectation := &BrokerMockIsKnownRequestExpectation{
		mock:   mmIsKnownRequest.mock,
		params: &BrokerMockIsKnownRequestParams{ctx, reqRef},
	}
	mmIsKnownRequest.expectations = append(mmIsKnownRequest.expectations, expectation)
	return expectation
}

// Then sets up Broker.IsKnownRequest return parameters for the expectation previously defined by the When method
func (e *BrokerMockIsKnownRequestExpectation) Then(b1 bool) *BrokerMock {
	e.results = &BrokerMockIsKnownRequestResults{b1}
	return e.mock
}

// IsKnownRequest implements Broker
func (mmIsKnownRequest *BrokerMock) IsKnownRequest(ctx context.Context, reqRef insolar.Reference) (b1 bool) {
	mm_atomic.AddUint64(&mmIsKnownRequest.beforeIsKnownRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmIsKnownRequest.afterIsKnownRequestCounter, 1)

	if mmIsKnownRequest.inspectFuncIsKnownRequest != nil {
		mmIsKnownRequest.inspectFuncIsKnownRequest(ctx, reqRef)
	}

	params := &BrokerMockIsKnownRequestParams{ctx, reqRef}

	// Record call args
	mmIsKnownRequest.IsKnownRequestMock.mutex.Lock()
	mmIsKnownRequest.IsKnownRequestMock.callArgs = append(mmIsKnownRequest.IsKnownRequestMock.callArgs, params)
	mmIsKnownRequest.IsKnownRequestMock.mutex.Unlock()

	for _, e := range mmIsKnownRequest.IsKnownRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsKnownRequest.IsKnownRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.Counter, 1)
		want := mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.params
		got := BrokerMockIsKnownRequestParams{ctx, reqRef}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsKnownRequest.t.Errorf("BrokerMock.IsKnownRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.results
		if results == nil {
			mmIsKnownRequest.t.Fatal("No results are set for the BrokerMock.IsKnownRequest")
		}
		return (*results).b1
	}
	if mmIsKnownRequest.funcIsKnownRequest != nil {
		return mmIsKnownRequest.funcIsKnownRequest(ctx, reqRef)
	}
	mmIsKnownRequest.t.Fatalf("Unexpected call to BrokerMock.IsKnownRequest. %v %v", ctx, reqRef)
	return
}

// IsKnownRequestAfterCounter returns a count of finished BrokerMock.IsKnownRequest invocations
func (mmIsKnownRequest *BrokerMock) IsKnownRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKnownRequest.afterIsKnownRequestCounter)
}

// IsKnownRequestBeforeCounter returns a count of BrokerMock.IsKnownRequest invocations
func (mmIsKnownRequest *BrokerMock) IsKnownRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKnownRequest.beforeIsKnownRequestCounter)
}

// Calls returns a list of arguments used in each call to BrokerMock.IsKnownRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsKnownRequest *mBrokerMockIsKnownRequest) Calls() []*BrokerMockIsKnownRequestParams {
	mmIsKnownRequest.mutex.RLock()

	argCopy := make([]*BrokerMockIsKnownRequestParams, len(mmIsKnownRequest.callArgs))
	copy(argCopy, mmIsKnownRequest.callArgs)

	mmIsKnownRequest.mutex.RUnlock()

	return argCopy
}

// MinimockIsKnownRequestDone returns true if the count of the IsKnownRequest invocations corresponds
// the number of defined expectations
func (m *BrokerMock) MinimockIsKnownRequestDone() bool {
	for _, e := range m.IsKnownRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsKnownRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsKnownRequest != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsKnownRequestInspect logs each unmet expectation
func (m *BrokerMock) MinimockIsKnownRequestInspect() {
	for _, e := range m.IsKnownRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerMock.IsKnownRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsKnownRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		if m.IsKnownRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerMock.IsKnownRequest")
		} else {
			m.t.Errorf("Expected call to BrokerMock.IsKnownRequest with params: %#v", *m.IsKnownRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsKnownRequest != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		m.t.Error("Expected call to BrokerMock.IsKnownRequest")
	}
}

type mBrokerMockNoMoreRequestsOnLedger struct {
	mock               *BrokerMock
	defaultExpectation *BrokerMockNoMoreRequestsOnLedgerExpectation
	expectations       []*BrokerMockNoMoreRequestsOnLedgerExpectation

	callArgs []*BrokerMockNoMoreRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// BrokerMockNoMoreRequestsOnLedgerExpectation specifies expectation struct of the Broker.NoMoreRequestsOnLedger
type BrokerMockNoMoreRequestsOnLedgerExpectation struct {
	mock   *BrokerMock
	params *BrokerMockNoMoreRequestsOnLedgerParams

	Counter uint64
}

// BrokerMockNoMoreRequestsOnLedgerParams contains parameters of the Broker.NoMoreRequestsOnLedger
type BrokerMockNoMoreRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for Broker.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mBrokerMockNoMoreRequestsOnLedger) Expect(ctx context.Context) *mBrokerMockNoMoreRequestsOnLedger {
	if mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("BrokerMock.NoMoreRequestsOnLedger mock is already set by Set")
	}

	if mmNoMoreRequestsOnLedger.defaultExpectation == nil {
		mmNoMoreRequestsOnLedger.defaultExpectation = &BrokerMockNoMoreRequestsOnLedgerExpectation{}
	}

	mmNoMoreRequestsOnLedger.defaultExpectation.params = &BrokerMockNoMoreRequestsOnLedgerParams{ctx}
	for _, e := range mmNoMoreRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmNoMoreRequestsOnLedger.defaultExpectation.params) {
			mmNoMoreRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNoMoreRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmNoMoreRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the Broker.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mBrokerMockNoMoreRequestsOnLedger) Inspect(f func(ctx context.Context)) *mBrokerMockNoMoreRequestsOnLedger {
	if mmNoMoreRequestsOnLedger.mock.inspectFuncNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for BrokerMock.NoMoreRequestsOnLedger")
	}

	mmNoMoreRequestsOnLedger.mock.inspectFuncNoMoreRequestsOnLedger = f

	return mmNoMoreRequestsOnLedger
}

// Return sets up results that will be returned by Broker.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mBrokerMockNoMoreRequestsOnLedger) Return() *BrokerMock {
	if mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("BrokerMock.NoMoreRequestsOnLedger mock is already set by Set")
	}

	if mmNoMoreRequestsOnLedger.defaultExpectation == nil {
		mmNoMoreRequestsOnLedger.defaultExpectation = &BrokerMockNoMoreRequestsOnLedgerExpectation{mock: mmNoMoreRequestsOnLedger.mock}
	}

	return mmNoMoreRequestsOnLedger.mock
}

//Set uses given function f to mock the Broker.NoMoreRequestsOnLedger method
func (mmNoMoreRequestsOnLedger *mBrokerMockNoMoreRequestsOnLedger) Set(f func(ctx context.Context)) *BrokerMock {
	if mmNoMoreRequestsOnLedger.defaultExpectation != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the Broker.NoMoreRequestsOnLedger method")
	}

	if len(mmNoMoreRequestsOnLedger.expectations) > 0 {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the Broker.NoMoreRequestsOnLedger method")
	}

	mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger = f
	return mmNoMoreRequestsOnLedger.mock
}

// NoMoreRequestsOnLedger implements Broker
func (mmNoMoreRequestsOnLedger *BrokerMock) NoMoreRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.beforeNoMoreRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.afterNoMoreRequestsOnLedgerCounter, 1)

	if mmNoMoreRequestsOnLedger.inspectFuncNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.inspectFuncNoMoreRequestsOnLedger(ctx)
	}

	params := &BrokerMockNoMoreRequestsOnLedgerParams{ctx}

	// Record call args
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.mutex.Lock()
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.callArgs = append(mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.callArgs, params)
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		want := mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation.params
		got := BrokerMockNoMoreRequestsOnLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmNoMoreRequestsOnLedger.t.Errorf("BrokerMock.NoMoreRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmNoMoreRequestsOnLedger.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.funcNoMoreRequestsOnLedger(ctx)
		return
	}
	mmNoMoreRequestsOnLedger.t.Fatalf("Unexpected call to BrokerMock.NoMoreRequestsOnLedger. %v", ctx)

}

// NoMoreRequestsOnLedgerAfterCounter returns a count of finished BrokerMock.NoMoreRequestsOnLedger invocations
func (mmNoMoreRequestsOnLedger *BrokerMock) NoMoreRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNoMoreRequestsOnLedger.afterNoMoreRequestsOnLedgerCounter)
}

// NoMoreRequestsOnLedgerBeforeCounter returns a count of BrokerMock.NoMoreRequestsOnLedger invocations
func (mmNoMoreRequestsOnLedger *BrokerMock) NoMoreRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNoMoreRequestsOnLedger.beforeNoMoreRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to BrokerMock.NoMoreRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNoMoreRequestsOnLedger *mBrokerMockNoMoreRequestsOnLedger) Calls() []*BrokerMockNoMoreRequestsOnLedgerParams {
	mmNoMoreRequestsOnLedger.mutex.RLock()

	argCopy := make([]*BrokerMockNoMoreRequestsOnLedgerParams, len(mmNoMoreRequestsOnLedger.callArgs))
	copy(argCopy, mmNoMoreRequestsOnLedger.callArgs)

	mmNoMoreRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockNoMoreRequestsOnLedgerDone returns true if the count of the NoMoreRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *BrokerMock) MinimockNoMoreRequestsOnLedgerDone() bool {
	for _, e := range m.NoMoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NoMoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNoMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockNoMoreRequestsOnLedgerInspect logs each unmet expectation
func (m *BrokerMock) MinimockNoMoreRequestsOnLedgerInspect() {
	for _, e := range m.NoMoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerMock.NoMoreRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NoMoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		if m.NoMoreRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerMock.NoMoreRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to BrokerMock.NoMoreRequestsOnLedger with params: %#v", *m.NoMoreRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNoMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to BrokerMock.NoMoreRequestsOnLedger")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BrokerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddRequestsFromLedgerInspect()

		m.MinimockIsKnownRequestInspect()

		m.MinimockNoMoreRequestsOnLedgerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BrokerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BrokerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddRequestsFromLedgerDone() &&
		m.MinimockIsKnownRequestDone() &&
		m.MinimockNoMoreRequestsOnLedgerDone()
}
