package executionbroker

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
	"github.com/insolar/insolar/insolar"
	"github.com/insolar/insolar/logicrunner/transcript"
)

// BrokerIMock implements BrokerI
type BrokerIMock struct {
	t minimock.Tester

	funcAbandonedRequestsOnLedger          func(ctx context.Context)
	inspectFuncAbandonedRequestsOnLedger   func(ctx context.Context)
	afterAbandonedRequestsOnLedgerCounter  uint64
	beforeAbandonedRequestsOnLedgerCounter uint64
	AbandonedRequestsOnLedgerMock          mBrokerIMockAbandonedRequestsOnLedger

	funcAddAdditionalRequestFromPrevExecutor          func(ctx context.Context, transcript *transcript.Transcript)
	inspectFuncAddAdditionalRequestFromPrevExecutor   func(ctx context.Context, transcript *transcript.Transcript)
	afterAddAdditionalRequestFromPrevExecutorCounter  uint64
	beforeAddAdditionalRequestFromPrevExecutorCounter uint64
	AddAdditionalRequestFromPrevExecutorMock          mBrokerIMockAddAdditionalRequestFromPrevExecutor

	funcAddFreshRequest          func(ctx context.Context, transcript *transcript.Transcript)
	inspectFuncAddFreshRequest   func(ctx context.Context, transcript *transcript.Transcript)
	afterAddFreshRequestCounter  uint64
	beforeAddFreshRequestCounter uint64
	AddFreshRequestMock          mBrokerIMockAddFreshRequest

	funcAddRequestsFromLedger          func(ctx context.Context, transcripts ...*transcript.Transcript)
	inspectFuncAddRequestsFromLedger   func(ctx context.Context, transcripts ...*transcript.Transcript)
	afterAddRequestsFromLedgerCounter  uint64
	beforeAddRequestsFromLedgerCounter uint64
	AddRequestsFromLedgerMock          mBrokerIMockAddRequestsFromLedger

	funcAddRequestsFromPrevExecutor          func(ctx context.Context, transcripts ...*transcript.Transcript)
	inspectFuncAddRequestsFromPrevExecutor   func(ctx context.Context, transcripts ...*transcript.Transcript)
	afterAddRequestsFromPrevExecutorCounter  uint64
	beforeAddRequestsFromPrevExecutorCounter uint64
	AddRequestsFromPrevExecutorMock          mBrokerIMockAddRequestsFromPrevExecutor

	funcFetchMoreRequestsFromLedger          func(ctx context.Context)
	inspectFuncFetchMoreRequestsFromLedger   func(ctx context.Context)
	afterFetchMoreRequestsFromLedgerCounter  uint64
	beforeFetchMoreRequestsFromLedgerCounter uint64
	FetchMoreRequestsFromLedgerMock          mBrokerIMockFetchMoreRequestsFromLedger

	funcGetActiveTranscript          func(req insolar.Reference) (tp1 *transcript.Transcript)
	inspectFuncGetActiveTranscript   func(req insolar.Reference)
	afterGetActiveTranscriptCounter  uint64
	beforeGetActiveTranscriptCounter uint64
	GetActiveTranscriptMock          mBrokerIMockGetActiveTranscript

	funcIsKnownRequest          func(ctx context.Context, req insolar.Reference) (b1 bool)
	inspectFuncIsKnownRequest   func(ctx context.Context, req insolar.Reference)
	afterIsKnownRequestCounter  uint64
	beforeIsKnownRequestCounter uint64
	IsKnownRequestMock          mBrokerIMockIsKnownRequest

	funcMoreRequestsOnLedger          func(ctx context.Context)
	inspectFuncMoreRequestsOnLedger   func(ctx context.Context)
	afterMoreRequestsOnLedgerCounter  uint64
	beforeMoreRequestsOnLedgerCounter uint64
	MoreRequestsOnLedgerMock          mBrokerIMockMoreRequestsOnLedger

	funcNoMoreRequestsOnLedger          func(ctx context.Context)
	inspectFuncNoMoreRequestsOnLedger   func(ctx context.Context)
	afterNoMoreRequestsOnLedgerCounter  uint64
	beforeNoMoreRequestsOnLedgerCounter uint64
	NoMoreRequestsOnLedgerMock          mBrokerIMockNoMoreRequestsOnLedger

	funcOnPulse          func(ctx context.Context, meNext bool) (ma1 []insolar.Message)
	inspectFuncOnPulse   func(ctx context.Context, meNext bool)
	afterOnPulseCounter  uint64
	beforeOnPulseCounter uint64
	OnPulseMock          mBrokerIMockOnPulse

	funcPendingState          func() (p1 insolar.PendingState)
	inspectFuncPendingState   func()
	afterPendingStateCounter  uint64
	beforePendingStateCounter uint64
	PendingStateMock          mBrokerIMockPendingState

	funcPrevExecutorFinishedPending          func(ctx context.Context) (err error)
	inspectFuncPrevExecutorFinishedPending   func(ctx context.Context)
	afterPrevExecutorFinishedPendingCounter  uint64
	beforePrevExecutorFinishedPendingCounter uint64
	PrevExecutorFinishedPendingMock          mBrokerIMockPrevExecutorFinishedPending

	funcPrevExecutorPendingResult          func(ctx context.Context, prevExecState insolar.PendingState)
	inspectFuncPrevExecutorPendingResult   func(ctx context.Context, prevExecState insolar.PendingState)
	afterPrevExecutorPendingResultCounter  uint64
	beforePrevExecutorPendingResultCounter uint64
	PrevExecutorPendingResultMock          mBrokerIMockPrevExecutorPendingResult

	funcPrevExecutorStillExecuting          func(ctx context.Context)
	inspectFuncPrevExecutorStillExecuting   func(ctx context.Context)
	afterPrevExecutorStillExecutingCounter  uint64
	beforePrevExecutorStillExecutingCounter uint64
	PrevExecutorStillExecutingMock          mBrokerIMockPrevExecutorStillExecuting

	funcSetNotPending          func(ctx context.Context)
	inspectFuncSetNotPending   func(ctx context.Context)
	afterSetNotPendingCounter  uint64
	beforeSetNotPendingCounter uint64
	SetNotPendingMock          mBrokerIMockSetNotPending
}

// NewBrokerIMock returns a mock for BrokerI
func NewBrokerIMock(t minimock.Tester) *BrokerIMock {
	m := &BrokerIMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AbandonedRequestsOnLedgerMock = mBrokerIMockAbandonedRequestsOnLedger{mock: m}
	m.AbandonedRequestsOnLedgerMock.callArgs = []*BrokerIMockAbandonedRequestsOnLedgerParams{}

	m.AddAdditionalRequestFromPrevExecutorMock = mBrokerIMockAddAdditionalRequestFromPrevExecutor{mock: m}
	m.AddAdditionalRequestFromPrevExecutorMock.callArgs = []*BrokerIMockAddAdditionalRequestFromPrevExecutorParams{}

	m.AddFreshRequestMock = mBrokerIMockAddFreshRequest{mock: m}
	m.AddFreshRequestMock.callArgs = []*BrokerIMockAddFreshRequestParams{}

	m.AddRequestsFromLedgerMock = mBrokerIMockAddRequestsFromLedger{mock: m}
	m.AddRequestsFromLedgerMock.callArgs = []*BrokerIMockAddRequestsFromLedgerParams{}

	m.AddRequestsFromPrevExecutorMock = mBrokerIMockAddRequestsFromPrevExecutor{mock: m}
	m.AddRequestsFromPrevExecutorMock.callArgs = []*BrokerIMockAddRequestsFromPrevExecutorParams{}

	m.FetchMoreRequestsFromLedgerMock = mBrokerIMockFetchMoreRequestsFromLedger{mock: m}
	m.FetchMoreRequestsFromLedgerMock.callArgs = []*BrokerIMockFetchMoreRequestsFromLedgerParams{}

	m.GetActiveTranscriptMock = mBrokerIMockGetActiveTranscript{mock: m}
	m.GetActiveTranscriptMock.callArgs = []*BrokerIMockGetActiveTranscriptParams{}

	m.IsKnownRequestMock = mBrokerIMockIsKnownRequest{mock: m}
	m.IsKnownRequestMock.callArgs = []*BrokerIMockIsKnownRequestParams{}

	m.MoreRequestsOnLedgerMock = mBrokerIMockMoreRequestsOnLedger{mock: m}
	m.MoreRequestsOnLedgerMock.callArgs = []*BrokerIMockMoreRequestsOnLedgerParams{}

	m.NoMoreRequestsOnLedgerMock = mBrokerIMockNoMoreRequestsOnLedger{mock: m}
	m.NoMoreRequestsOnLedgerMock.callArgs = []*BrokerIMockNoMoreRequestsOnLedgerParams{}

	m.OnPulseMock = mBrokerIMockOnPulse{mock: m}
	m.OnPulseMock.callArgs = []*BrokerIMockOnPulseParams{}

	m.PendingStateMock = mBrokerIMockPendingState{mock: m}

	m.PrevExecutorFinishedPendingMock = mBrokerIMockPrevExecutorFinishedPending{mock: m}
	m.PrevExecutorFinishedPendingMock.callArgs = []*BrokerIMockPrevExecutorFinishedPendingParams{}

	m.PrevExecutorPendingResultMock = mBrokerIMockPrevExecutorPendingResult{mock: m}
	m.PrevExecutorPendingResultMock.callArgs = []*BrokerIMockPrevExecutorPendingResultParams{}

	m.PrevExecutorStillExecutingMock = mBrokerIMockPrevExecutorStillExecuting{mock: m}
	m.PrevExecutorStillExecutingMock.callArgs = []*BrokerIMockPrevExecutorStillExecutingParams{}

	m.SetNotPendingMock = mBrokerIMockSetNotPending{mock: m}
	m.SetNotPendingMock.callArgs = []*BrokerIMockSetNotPendingParams{}

	return m
}

type mBrokerIMockAbandonedRequestsOnLedger struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockAbandonedRequestsOnLedgerExpectation
	expectations       []*BrokerIMockAbandonedRequestsOnLedgerExpectation

	callArgs []*BrokerIMockAbandonedRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// BrokerIMockAbandonedRequestsOnLedgerExpectation specifies expectation struct of the BrokerI.AbandonedRequestsOnLedger
type BrokerIMockAbandonedRequestsOnLedgerExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockAbandonedRequestsOnLedgerParams

	Counter uint64
}

// BrokerIMockAbandonedRequestsOnLedgerParams contains parameters of the BrokerI.AbandonedRequestsOnLedger
type BrokerIMockAbandonedRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for BrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mBrokerIMockAbandonedRequestsOnLedger) Expect(ctx context.Context) *mBrokerIMockAbandonedRequestsOnLedger {
	if mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("BrokerIMock.AbandonedRequestsOnLedger mock is already set by Set")
	}

	if mmAbandonedRequestsOnLedger.defaultExpectation == nil {
		mmAbandonedRequestsOnLedger.defaultExpectation = &BrokerIMockAbandonedRequestsOnLedgerExpectation{}
	}

	mmAbandonedRequestsOnLedger.defaultExpectation.params = &BrokerIMockAbandonedRequestsOnLedgerParams{ctx}
	for _, e := range mmAbandonedRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmAbandonedRequestsOnLedger.defaultExpectation.params) {
			mmAbandonedRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAbandonedRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmAbandonedRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mBrokerIMockAbandonedRequestsOnLedger) Inspect(f func(ctx context.Context)) *mBrokerIMockAbandonedRequestsOnLedger {
	if mmAbandonedRequestsOnLedger.mock.inspectFuncAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for BrokerIMock.AbandonedRequestsOnLedger")
	}

	mmAbandonedRequestsOnLedger.mock.inspectFuncAbandonedRequestsOnLedger = f

	return mmAbandonedRequestsOnLedger
}

// Return sets up results that will be returned by BrokerI.AbandonedRequestsOnLedger
func (mmAbandonedRequestsOnLedger *mBrokerIMockAbandonedRequestsOnLedger) Return() *BrokerIMock {
	if mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("BrokerIMock.AbandonedRequestsOnLedger mock is already set by Set")
	}

	if mmAbandonedRequestsOnLedger.defaultExpectation == nil {
		mmAbandonedRequestsOnLedger.defaultExpectation = &BrokerIMockAbandonedRequestsOnLedgerExpectation{mock: mmAbandonedRequestsOnLedger.mock}
	}

	return mmAbandonedRequestsOnLedger.mock
}

//Set uses given function f to mock the BrokerI.AbandonedRequestsOnLedger method
func (mmAbandonedRequestsOnLedger *mBrokerIMockAbandonedRequestsOnLedger) Set(f func(ctx context.Context)) *BrokerIMock {
	if mmAbandonedRequestsOnLedger.defaultExpectation != nil {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the BrokerI.AbandonedRequestsOnLedger method")
	}

	if len(mmAbandonedRequestsOnLedger.expectations) > 0 {
		mmAbandonedRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the BrokerI.AbandonedRequestsOnLedger method")
	}

	mmAbandonedRequestsOnLedger.mock.funcAbandonedRequestsOnLedger = f
	return mmAbandonedRequestsOnLedger.mock
}

// AbandonedRequestsOnLedger implements BrokerI
func (mmAbandonedRequestsOnLedger *BrokerIMock) AbandonedRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.beforeAbandonedRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.afterAbandonedRequestsOnLedgerCounter, 1)

	if mmAbandonedRequestsOnLedger.inspectFuncAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.inspectFuncAbandonedRequestsOnLedger(ctx)
	}

	params := &BrokerIMockAbandonedRequestsOnLedgerParams{ctx}

	// Record call args
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.mutex.Lock()
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.callArgs = append(mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.callArgs, params)
	mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		want := mmAbandonedRequestsOnLedger.AbandonedRequestsOnLedgerMock.defaultExpectation.params
		got := BrokerIMockAbandonedRequestsOnLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmAbandonedRequestsOnLedger.t.Errorf("BrokerIMock.AbandonedRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAbandonedRequestsOnLedger.funcAbandonedRequestsOnLedger != nil {
		mmAbandonedRequestsOnLedger.funcAbandonedRequestsOnLedger(ctx)
		return
	}
	mmAbandonedRequestsOnLedger.t.Fatalf("Unexpected call to BrokerIMock.AbandonedRequestsOnLedger. %v", ctx)

}

// AbandonedRequestsOnLedgerAfterCounter returns a count of finished BrokerIMock.AbandonedRequestsOnLedger invocations
func (mmAbandonedRequestsOnLedger *BrokerIMock) AbandonedRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbandonedRequestsOnLedger.afterAbandonedRequestsOnLedgerCounter)
}

// AbandonedRequestsOnLedgerBeforeCounter returns a count of BrokerIMock.AbandonedRequestsOnLedger invocations
func (mmAbandonedRequestsOnLedger *BrokerIMock) AbandonedRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbandonedRequestsOnLedger.beforeAbandonedRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.AbandonedRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAbandonedRequestsOnLedger *mBrokerIMockAbandonedRequestsOnLedger) Calls() []*BrokerIMockAbandonedRequestsOnLedgerParams {
	mmAbandonedRequestsOnLedger.mutex.RLock()

	argCopy := make([]*BrokerIMockAbandonedRequestsOnLedgerParams, len(mmAbandonedRequestsOnLedger.callArgs))
	copy(argCopy, mmAbandonedRequestsOnLedger.callArgs)

	mmAbandonedRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockAbandonedRequestsOnLedgerDone returns true if the count of the AbandonedRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockAbandonedRequestsOnLedgerDone() bool {
	for _, e := range m.AbandonedRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbandonedRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbandonedRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAbandonedRequestsOnLedgerInspect logs each unmet expectation
func (m *BrokerIMock) MinimockAbandonedRequestsOnLedgerInspect() {
	for _, e := range m.AbandonedRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.AbandonedRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AbandonedRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		if m.AbandonedRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.AbandonedRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.AbandonedRequestsOnLedger with params: %#v", *m.AbandonedRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbandonedRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterAbandonedRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.AbandonedRequestsOnLedger")
	}
}

type mBrokerIMockAddAdditionalRequestFromPrevExecutor struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockAddAdditionalRequestFromPrevExecutorExpectation
	expectations       []*BrokerIMockAddAdditionalRequestFromPrevExecutorExpectation

	callArgs []*BrokerIMockAddAdditionalRequestFromPrevExecutorParams
	mutex    sync.RWMutex
}

// BrokerIMockAddAdditionalRequestFromPrevExecutorExpectation specifies expectation struct of the BrokerI.AddAdditionalRequestFromPrevExecutor
type BrokerIMockAddAdditionalRequestFromPrevExecutorExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockAddAdditionalRequestFromPrevExecutorParams

	Counter uint64
}

// BrokerIMockAddAdditionalRequestFromPrevExecutorParams contains parameters of the BrokerI.AddAdditionalRequestFromPrevExecutor
type BrokerIMockAddAdditionalRequestFromPrevExecutorParams struct {
	ctx        context.Context
	transcript *transcript.Transcript
}

// Expect sets up expected params for BrokerI.AddAdditionalRequestFromPrevExecutor
func (mmAddAdditionalRequestFromPrevExecutor *mBrokerIMockAddAdditionalRequestFromPrevExecutor) Expect(ctx context.Context, transcript *transcript.Transcript) *mBrokerIMockAddAdditionalRequestFromPrevExecutor {
	if mmAddAdditionalRequestFromPrevExecutor.mock.funcAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("BrokerIMock.AddAdditionalRequestFromPrevExecutor mock is already set by Set")
	}

	if mmAddAdditionalRequestFromPrevExecutor.defaultExpectation == nil {
		mmAddAdditionalRequestFromPrevExecutor.defaultExpectation = &BrokerIMockAddAdditionalRequestFromPrevExecutorExpectation{}
	}

	mmAddAdditionalRequestFromPrevExecutor.defaultExpectation.params = &BrokerIMockAddAdditionalRequestFromPrevExecutorParams{ctx, transcript}
	for _, e := range mmAddAdditionalRequestFromPrevExecutor.expectations {
		if minimock.Equal(e.params, mmAddAdditionalRequestFromPrevExecutor.defaultExpectation.params) {
			mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddAdditionalRequestFromPrevExecutor.defaultExpectation.params)
		}
	}

	return mmAddAdditionalRequestFromPrevExecutor
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.AddAdditionalRequestFromPrevExecutor
func (mmAddAdditionalRequestFromPrevExecutor *mBrokerIMockAddAdditionalRequestFromPrevExecutor) Inspect(f func(ctx context.Context, transcript *transcript.Transcript)) *mBrokerIMockAddAdditionalRequestFromPrevExecutor {
	if mmAddAdditionalRequestFromPrevExecutor.mock.inspectFuncAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Inspect function is already set for BrokerIMock.AddAdditionalRequestFromPrevExecutor")
	}

	mmAddAdditionalRequestFromPrevExecutor.mock.inspectFuncAddAdditionalRequestFromPrevExecutor = f

	return mmAddAdditionalRequestFromPrevExecutor
}

// Return sets up results that will be returned by BrokerI.AddAdditionalRequestFromPrevExecutor
func (mmAddAdditionalRequestFromPrevExecutor *mBrokerIMockAddAdditionalRequestFromPrevExecutor) Return() *BrokerIMock {
	if mmAddAdditionalRequestFromPrevExecutor.mock.funcAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("BrokerIMock.AddAdditionalRequestFromPrevExecutor mock is already set by Set")
	}

	if mmAddAdditionalRequestFromPrevExecutor.defaultExpectation == nil {
		mmAddAdditionalRequestFromPrevExecutor.defaultExpectation = &BrokerIMockAddAdditionalRequestFromPrevExecutorExpectation{mock: mmAddAdditionalRequestFromPrevExecutor.mock}
	}

	return mmAddAdditionalRequestFromPrevExecutor.mock
}

//Set uses given function f to mock the BrokerI.AddAdditionalRequestFromPrevExecutor method
func (mmAddAdditionalRequestFromPrevExecutor *mBrokerIMockAddAdditionalRequestFromPrevExecutor) Set(f func(ctx context.Context, transcript *transcript.Transcript)) *BrokerIMock {
	if mmAddAdditionalRequestFromPrevExecutor.defaultExpectation != nil {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Default expectation is already set for the BrokerI.AddAdditionalRequestFromPrevExecutor method")
	}

	if len(mmAddAdditionalRequestFromPrevExecutor.expectations) > 0 {
		mmAddAdditionalRequestFromPrevExecutor.mock.t.Fatalf("Some expectations are already set for the BrokerI.AddAdditionalRequestFromPrevExecutor method")
	}

	mmAddAdditionalRequestFromPrevExecutor.mock.funcAddAdditionalRequestFromPrevExecutor = f
	return mmAddAdditionalRequestFromPrevExecutor.mock
}

// AddAdditionalRequestFromPrevExecutor implements BrokerI
func (mmAddAdditionalRequestFromPrevExecutor *BrokerIMock) AddAdditionalRequestFromPrevExecutor(ctx context.Context, transcript *transcript.Transcript) {
	mm_atomic.AddUint64(&mmAddAdditionalRequestFromPrevExecutor.beforeAddAdditionalRequestFromPrevExecutorCounter, 1)
	defer mm_atomic.AddUint64(&mmAddAdditionalRequestFromPrevExecutor.afterAddAdditionalRequestFromPrevExecutorCounter, 1)

	if mmAddAdditionalRequestFromPrevExecutor.inspectFuncAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.inspectFuncAddAdditionalRequestFromPrevExecutor(ctx, transcript)
	}

	params := &BrokerIMockAddAdditionalRequestFromPrevExecutorParams{ctx, transcript}

	// Record call args
	mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.mutex.Lock()
	mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.callArgs = append(mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.callArgs, params)
	mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.mutex.Unlock()

	for _, e := range mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.Counter, 1)
		want := mmAddAdditionalRequestFromPrevExecutor.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.params
		got := BrokerIMockAddAdditionalRequestFromPrevExecutorParams{ctx, transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddAdditionalRequestFromPrevExecutor.t.Errorf("BrokerIMock.AddAdditionalRequestFromPrevExecutor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddAdditionalRequestFromPrevExecutor.funcAddAdditionalRequestFromPrevExecutor != nil {
		mmAddAdditionalRequestFromPrevExecutor.funcAddAdditionalRequestFromPrevExecutor(ctx, transcript)
		return
	}
	mmAddAdditionalRequestFromPrevExecutor.t.Fatalf("Unexpected call to BrokerIMock.AddAdditionalRequestFromPrevExecutor. %v %v", ctx, transcript)

}

// AddAdditionalRequestFromPrevExecutorAfterCounter returns a count of finished BrokerIMock.AddAdditionalRequestFromPrevExecutor invocations
func (mmAddAdditionalRequestFromPrevExecutor *BrokerIMock) AddAdditionalRequestFromPrevExecutorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAdditionalRequestFromPrevExecutor.afterAddAdditionalRequestFromPrevExecutorCounter)
}

// AddAdditionalRequestFromPrevExecutorBeforeCounter returns a count of BrokerIMock.AddAdditionalRequestFromPrevExecutor invocations
func (mmAddAdditionalRequestFromPrevExecutor *BrokerIMock) AddAdditionalRequestFromPrevExecutorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAdditionalRequestFromPrevExecutor.beforeAddAdditionalRequestFromPrevExecutorCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.AddAdditionalRequestFromPrevExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddAdditionalRequestFromPrevExecutor *mBrokerIMockAddAdditionalRequestFromPrevExecutor) Calls() []*BrokerIMockAddAdditionalRequestFromPrevExecutorParams {
	mmAddAdditionalRequestFromPrevExecutor.mutex.RLock()

	argCopy := make([]*BrokerIMockAddAdditionalRequestFromPrevExecutorParams, len(mmAddAdditionalRequestFromPrevExecutor.callArgs))
	copy(argCopy, mmAddAdditionalRequestFromPrevExecutor.callArgs)

	mmAddAdditionalRequestFromPrevExecutor.mutex.RUnlock()

	return argCopy
}

// MinimockAddAdditionalRequestFromPrevExecutorDone returns true if the count of the AddAdditionalRequestFromPrevExecutor invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockAddAdditionalRequestFromPrevExecutorDone() bool {
	for _, e := range m.AddAdditionalRequestFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAdditionalRequestFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddAdditionalRequestFromPrevExecutorInspect logs each unmet expectation
func (m *BrokerIMock) MinimockAddAdditionalRequestFromPrevExecutorInspect() {
	for _, e := range m.AddAdditionalRequestFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.AddAdditionalRequestFromPrevExecutor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		if m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.AddAdditionalRequestFromPrevExecutor")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.AddAdditionalRequestFromPrevExecutor with params: %#v", *m.AddAdditionalRequestFromPrevExecutorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAdditionalRequestFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddAdditionalRequestFromPrevExecutorCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.AddAdditionalRequestFromPrevExecutor")
	}
}

type mBrokerIMockAddFreshRequest struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockAddFreshRequestExpectation
	expectations       []*BrokerIMockAddFreshRequestExpectation

	callArgs []*BrokerIMockAddFreshRequestParams
	mutex    sync.RWMutex
}

// BrokerIMockAddFreshRequestExpectation specifies expectation struct of the BrokerI.AddFreshRequest
type BrokerIMockAddFreshRequestExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockAddFreshRequestParams

	Counter uint64
}

// BrokerIMockAddFreshRequestParams contains parameters of the BrokerI.AddFreshRequest
type BrokerIMockAddFreshRequestParams struct {
	ctx        context.Context
	transcript *transcript.Transcript
}

// Expect sets up expected params for BrokerI.AddFreshRequest
func (mmAddFreshRequest *mBrokerIMockAddFreshRequest) Expect(ctx context.Context, transcript *transcript.Transcript) *mBrokerIMockAddFreshRequest {
	if mmAddFreshRequest.mock.funcAddFreshRequest != nil {
		mmAddFreshRequest.mock.t.Fatalf("BrokerIMock.AddFreshRequest mock is already set by Set")
	}

	if mmAddFreshRequest.defaultExpectation == nil {
		mmAddFreshRequest.defaultExpectation = &BrokerIMockAddFreshRequestExpectation{}
	}

	mmAddFreshRequest.defaultExpectation.params = &BrokerIMockAddFreshRequestParams{ctx, transcript}
	for _, e := range mmAddFreshRequest.expectations {
		if minimock.Equal(e.params, mmAddFreshRequest.defaultExpectation.params) {
			mmAddFreshRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddFreshRequest.defaultExpectation.params)
		}
	}

	return mmAddFreshRequest
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.AddFreshRequest
func (mmAddFreshRequest *mBrokerIMockAddFreshRequest) Inspect(f func(ctx context.Context, transcript *transcript.Transcript)) *mBrokerIMockAddFreshRequest {
	if mmAddFreshRequest.mock.inspectFuncAddFreshRequest != nil {
		mmAddFreshRequest.mock.t.Fatalf("Inspect function is already set for BrokerIMock.AddFreshRequest")
	}

	mmAddFreshRequest.mock.inspectFuncAddFreshRequest = f

	return mmAddFreshRequest
}

// Return sets up results that will be returned by BrokerI.AddFreshRequest
func (mmAddFreshRequest *mBrokerIMockAddFreshRequest) Return() *BrokerIMock {
	if mmAddFreshRequest.mock.funcAddFreshRequest != nil {
		mmAddFreshRequest.mock.t.Fatalf("BrokerIMock.AddFreshRequest mock is already set by Set")
	}

	if mmAddFreshRequest.defaultExpectation == nil {
		mmAddFreshRequest.defaultExpectation = &BrokerIMockAddFreshRequestExpectation{mock: mmAddFreshRequest.mock}
	}

	return mmAddFreshRequest.mock
}

//Set uses given function f to mock the BrokerI.AddFreshRequest method
func (mmAddFreshRequest *mBrokerIMockAddFreshRequest) Set(f func(ctx context.Context, transcript *transcript.Transcript)) *BrokerIMock {
	if mmAddFreshRequest.defaultExpectation != nil {
		mmAddFreshRequest.mock.t.Fatalf("Default expectation is already set for the BrokerI.AddFreshRequest method")
	}

	if len(mmAddFreshRequest.expectations) > 0 {
		mmAddFreshRequest.mock.t.Fatalf("Some expectations are already set for the BrokerI.AddFreshRequest method")
	}

	mmAddFreshRequest.mock.funcAddFreshRequest = f
	return mmAddFreshRequest.mock
}

// AddFreshRequest implements BrokerI
func (mmAddFreshRequest *BrokerIMock) AddFreshRequest(ctx context.Context, transcript *transcript.Transcript) {
	mm_atomic.AddUint64(&mmAddFreshRequest.beforeAddFreshRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmAddFreshRequest.afterAddFreshRequestCounter, 1)

	if mmAddFreshRequest.inspectFuncAddFreshRequest != nil {
		mmAddFreshRequest.inspectFuncAddFreshRequest(ctx, transcript)
	}

	params := &BrokerIMockAddFreshRequestParams{ctx, transcript}

	// Record call args
	mmAddFreshRequest.AddFreshRequestMock.mutex.Lock()
	mmAddFreshRequest.AddFreshRequestMock.callArgs = append(mmAddFreshRequest.AddFreshRequestMock.callArgs, params)
	mmAddFreshRequest.AddFreshRequestMock.mutex.Unlock()

	for _, e := range mmAddFreshRequest.AddFreshRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddFreshRequest.AddFreshRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddFreshRequest.AddFreshRequestMock.defaultExpectation.Counter, 1)
		want := mmAddFreshRequest.AddFreshRequestMock.defaultExpectation.params
		got := BrokerIMockAddFreshRequestParams{ctx, transcript}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddFreshRequest.t.Errorf("BrokerIMock.AddFreshRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddFreshRequest.funcAddFreshRequest != nil {
		mmAddFreshRequest.funcAddFreshRequest(ctx, transcript)
		return
	}
	mmAddFreshRequest.t.Fatalf("Unexpected call to BrokerIMock.AddFreshRequest. %v %v", ctx, transcript)

}

// AddFreshRequestAfterCounter returns a count of finished BrokerIMock.AddFreshRequest invocations
func (mmAddFreshRequest *BrokerIMock) AddFreshRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFreshRequest.afterAddFreshRequestCounter)
}

// AddFreshRequestBeforeCounter returns a count of BrokerIMock.AddFreshRequest invocations
func (mmAddFreshRequest *BrokerIMock) AddFreshRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddFreshRequest.beforeAddFreshRequestCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.AddFreshRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddFreshRequest *mBrokerIMockAddFreshRequest) Calls() []*BrokerIMockAddFreshRequestParams {
	mmAddFreshRequest.mutex.RLock()

	argCopy := make([]*BrokerIMockAddFreshRequestParams, len(mmAddFreshRequest.callArgs))
	copy(argCopy, mmAddFreshRequest.callArgs)

	mmAddFreshRequest.mutex.RUnlock()

	return argCopy
}

// MinimockAddFreshRequestDone returns true if the count of the AddFreshRequest invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockAddFreshRequestDone() bool {
	for _, e := range m.AddFreshRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFreshRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFreshRequest != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddFreshRequestInspect logs each unmet expectation
func (m *BrokerIMock) MinimockAddFreshRequestInspect() {
	for _, e := range m.AddFreshRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.AddFreshRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddFreshRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		if m.AddFreshRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.AddFreshRequest")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.AddFreshRequest with params: %#v", *m.AddFreshRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddFreshRequest != nil && mm_atomic.LoadUint64(&m.afterAddFreshRequestCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.AddFreshRequest")
	}
}

type mBrokerIMockAddRequestsFromLedger struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockAddRequestsFromLedgerExpectation
	expectations       []*BrokerIMockAddRequestsFromLedgerExpectation

	callArgs []*BrokerIMockAddRequestsFromLedgerParams
	mutex    sync.RWMutex
}

// BrokerIMockAddRequestsFromLedgerExpectation specifies expectation struct of the BrokerI.AddRequestsFromLedger
type BrokerIMockAddRequestsFromLedgerExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockAddRequestsFromLedgerParams

	Counter uint64
}

// BrokerIMockAddRequestsFromLedgerParams contains parameters of the BrokerI.AddRequestsFromLedger
type BrokerIMockAddRequestsFromLedgerParams struct {
	ctx         context.Context
	transcripts []*transcript.Transcript
}

// Expect sets up expected params for BrokerI.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mBrokerIMockAddRequestsFromLedger) Expect(ctx context.Context, transcripts ...*transcript.Transcript) *mBrokerIMockAddRequestsFromLedger {
	if mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("BrokerIMock.AddRequestsFromLedger mock is already set by Set")
	}

	if mmAddRequestsFromLedger.defaultExpectation == nil {
		mmAddRequestsFromLedger.defaultExpectation = &BrokerIMockAddRequestsFromLedgerExpectation{}
	}

	mmAddRequestsFromLedger.defaultExpectation.params = &BrokerIMockAddRequestsFromLedgerParams{ctx, transcripts}
	for _, e := range mmAddRequestsFromLedger.expectations {
		if minimock.Equal(e.params, mmAddRequestsFromLedger.defaultExpectation.params) {
			mmAddRequestsFromLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRequestsFromLedger.defaultExpectation.params)
		}
	}

	return mmAddRequestsFromLedger
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mBrokerIMockAddRequestsFromLedger) Inspect(f func(ctx context.Context, transcripts ...*transcript.Transcript)) *mBrokerIMockAddRequestsFromLedger {
	if mmAddRequestsFromLedger.mock.inspectFuncAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("Inspect function is already set for BrokerIMock.AddRequestsFromLedger")
	}

	mmAddRequestsFromLedger.mock.inspectFuncAddRequestsFromLedger = f

	return mmAddRequestsFromLedger
}

// Return sets up results that will be returned by BrokerI.AddRequestsFromLedger
func (mmAddRequestsFromLedger *mBrokerIMockAddRequestsFromLedger) Return() *BrokerIMock {
	if mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("BrokerIMock.AddRequestsFromLedger mock is already set by Set")
	}

	if mmAddRequestsFromLedger.defaultExpectation == nil {
		mmAddRequestsFromLedger.defaultExpectation = &BrokerIMockAddRequestsFromLedgerExpectation{mock: mmAddRequestsFromLedger.mock}
	}

	return mmAddRequestsFromLedger.mock
}

//Set uses given function f to mock the BrokerI.AddRequestsFromLedger method
func (mmAddRequestsFromLedger *mBrokerIMockAddRequestsFromLedger) Set(f func(ctx context.Context, transcripts ...*transcript.Transcript)) *BrokerIMock {
	if mmAddRequestsFromLedger.defaultExpectation != nil {
		mmAddRequestsFromLedger.mock.t.Fatalf("Default expectation is already set for the BrokerI.AddRequestsFromLedger method")
	}

	if len(mmAddRequestsFromLedger.expectations) > 0 {
		mmAddRequestsFromLedger.mock.t.Fatalf("Some expectations are already set for the BrokerI.AddRequestsFromLedger method")
	}

	mmAddRequestsFromLedger.mock.funcAddRequestsFromLedger = f
	return mmAddRequestsFromLedger.mock
}

// AddRequestsFromLedger implements BrokerI
func (mmAddRequestsFromLedger *BrokerIMock) AddRequestsFromLedger(ctx context.Context, transcripts ...*transcript.Transcript) {
	mm_atomic.AddUint64(&mmAddRequestsFromLedger.beforeAddRequestsFromLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRequestsFromLedger.afterAddRequestsFromLedgerCounter, 1)

	if mmAddRequestsFromLedger.inspectFuncAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.inspectFuncAddRequestsFromLedger(ctx, transcripts...)
	}

	params := &BrokerIMockAddRequestsFromLedgerParams{ctx, transcripts}

	// Record call args
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.mutex.Lock()
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.callArgs = append(mmAddRequestsFromLedger.AddRequestsFromLedgerMock.callArgs, params)
	mmAddRequestsFromLedger.AddRequestsFromLedgerMock.mutex.Unlock()

	for _, e := range mmAddRequestsFromLedger.AddRequestsFromLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation.Counter, 1)
		want := mmAddRequestsFromLedger.AddRequestsFromLedgerMock.defaultExpectation.params
		got := BrokerIMockAddRequestsFromLedgerParams{ctx, transcripts}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddRequestsFromLedger.t.Errorf("BrokerIMock.AddRequestsFromLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddRequestsFromLedger.funcAddRequestsFromLedger != nil {
		mmAddRequestsFromLedger.funcAddRequestsFromLedger(ctx, transcripts...)
		return
	}
	mmAddRequestsFromLedger.t.Fatalf("Unexpected call to BrokerIMock.AddRequestsFromLedger. %v %v", ctx, transcripts)

}

// AddRequestsFromLedgerAfterCounter returns a count of finished BrokerIMock.AddRequestsFromLedger invocations
func (mmAddRequestsFromLedger *BrokerIMock) AddRequestsFromLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromLedger.afterAddRequestsFromLedgerCounter)
}

// AddRequestsFromLedgerBeforeCounter returns a count of BrokerIMock.AddRequestsFromLedger invocations
func (mmAddRequestsFromLedger *BrokerIMock) AddRequestsFromLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromLedger.beforeAddRequestsFromLedgerCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.AddRequestsFromLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRequestsFromLedger *mBrokerIMockAddRequestsFromLedger) Calls() []*BrokerIMockAddRequestsFromLedgerParams {
	mmAddRequestsFromLedger.mutex.RLock()

	argCopy := make([]*BrokerIMockAddRequestsFromLedgerParams, len(mmAddRequestsFromLedger.callArgs))
	copy(argCopy, mmAddRequestsFromLedger.callArgs)

	mmAddRequestsFromLedger.mutex.RUnlock()

	return argCopy
}

// MinimockAddRequestsFromLedgerDone returns true if the count of the AddRequestsFromLedger invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockAddRequestsFromLedgerDone() bool {
	for _, e := range m.AddRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddRequestsFromLedgerInspect logs each unmet expectation
func (m *BrokerIMock) MinimockAddRequestsFromLedgerInspect() {
	for _, e := range m.AddRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.AddRequestsFromLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		if m.AddRequestsFromLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.AddRequestsFromLedger")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.AddRequestsFromLedger with params: %#v", *m.AddRequestsFromLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromLedgerCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.AddRequestsFromLedger")
	}
}

type mBrokerIMockAddRequestsFromPrevExecutor struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockAddRequestsFromPrevExecutorExpectation
	expectations       []*BrokerIMockAddRequestsFromPrevExecutorExpectation

	callArgs []*BrokerIMockAddRequestsFromPrevExecutorParams
	mutex    sync.RWMutex
}

// BrokerIMockAddRequestsFromPrevExecutorExpectation specifies expectation struct of the BrokerI.AddRequestsFromPrevExecutor
type BrokerIMockAddRequestsFromPrevExecutorExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockAddRequestsFromPrevExecutorParams

	Counter uint64
}

// BrokerIMockAddRequestsFromPrevExecutorParams contains parameters of the BrokerI.AddRequestsFromPrevExecutor
type BrokerIMockAddRequestsFromPrevExecutorParams struct {
	ctx         context.Context
	transcripts []*transcript.Transcript
}

// Expect sets up expected params for BrokerI.AddRequestsFromPrevExecutor
func (mmAddRequestsFromPrevExecutor *mBrokerIMockAddRequestsFromPrevExecutor) Expect(ctx context.Context, transcripts ...*transcript.Transcript) *mBrokerIMockAddRequestsFromPrevExecutor {
	if mmAddRequestsFromPrevExecutor.mock.funcAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("BrokerIMock.AddRequestsFromPrevExecutor mock is already set by Set")
	}

	if mmAddRequestsFromPrevExecutor.defaultExpectation == nil {
		mmAddRequestsFromPrevExecutor.defaultExpectation = &BrokerIMockAddRequestsFromPrevExecutorExpectation{}
	}

	mmAddRequestsFromPrevExecutor.defaultExpectation.params = &BrokerIMockAddRequestsFromPrevExecutorParams{ctx, transcripts}
	for _, e := range mmAddRequestsFromPrevExecutor.expectations {
		if minimock.Equal(e.params, mmAddRequestsFromPrevExecutor.defaultExpectation.params) {
			mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRequestsFromPrevExecutor.defaultExpectation.params)
		}
	}

	return mmAddRequestsFromPrevExecutor
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.AddRequestsFromPrevExecutor
func (mmAddRequestsFromPrevExecutor *mBrokerIMockAddRequestsFromPrevExecutor) Inspect(f func(ctx context.Context, transcripts ...*transcript.Transcript)) *mBrokerIMockAddRequestsFromPrevExecutor {
	if mmAddRequestsFromPrevExecutor.mock.inspectFuncAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Inspect function is already set for BrokerIMock.AddRequestsFromPrevExecutor")
	}

	mmAddRequestsFromPrevExecutor.mock.inspectFuncAddRequestsFromPrevExecutor = f

	return mmAddRequestsFromPrevExecutor
}

// Return sets up results that will be returned by BrokerI.AddRequestsFromPrevExecutor
func (mmAddRequestsFromPrevExecutor *mBrokerIMockAddRequestsFromPrevExecutor) Return() *BrokerIMock {
	if mmAddRequestsFromPrevExecutor.mock.funcAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("BrokerIMock.AddRequestsFromPrevExecutor mock is already set by Set")
	}

	if mmAddRequestsFromPrevExecutor.defaultExpectation == nil {
		mmAddRequestsFromPrevExecutor.defaultExpectation = &BrokerIMockAddRequestsFromPrevExecutorExpectation{mock: mmAddRequestsFromPrevExecutor.mock}
	}

	return mmAddRequestsFromPrevExecutor.mock
}

//Set uses given function f to mock the BrokerI.AddRequestsFromPrevExecutor method
func (mmAddRequestsFromPrevExecutor *mBrokerIMockAddRequestsFromPrevExecutor) Set(f func(ctx context.Context, transcripts ...*transcript.Transcript)) *BrokerIMock {
	if mmAddRequestsFromPrevExecutor.defaultExpectation != nil {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Default expectation is already set for the BrokerI.AddRequestsFromPrevExecutor method")
	}

	if len(mmAddRequestsFromPrevExecutor.expectations) > 0 {
		mmAddRequestsFromPrevExecutor.mock.t.Fatalf("Some expectations are already set for the BrokerI.AddRequestsFromPrevExecutor method")
	}

	mmAddRequestsFromPrevExecutor.mock.funcAddRequestsFromPrevExecutor = f
	return mmAddRequestsFromPrevExecutor.mock
}

// AddRequestsFromPrevExecutor implements BrokerI
func (mmAddRequestsFromPrevExecutor *BrokerIMock) AddRequestsFromPrevExecutor(ctx context.Context, transcripts ...*transcript.Transcript) {
	mm_atomic.AddUint64(&mmAddRequestsFromPrevExecutor.beforeAddRequestsFromPrevExecutorCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRequestsFromPrevExecutor.afterAddRequestsFromPrevExecutorCounter, 1)

	if mmAddRequestsFromPrevExecutor.inspectFuncAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.inspectFuncAddRequestsFromPrevExecutor(ctx, transcripts...)
	}

	params := &BrokerIMockAddRequestsFromPrevExecutorParams{ctx, transcripts}

	// Record call args
	mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.mutex.Lock()
	mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.callArgs = append(mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.callArgs, params)
	mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.mutex.Unlock()

	for _, e := range mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.defaultExpectation.Counter, 1)
		want := mmAddRequestsFromPrevExecutor.AddRequestsFromPrevExecutorMock.defaultExpectation.params
		got := BrokerIMockAddRequestsFromPrevExecutorParams{ctx, transcripts}
		if want != nil && !minimock.Equal(*want, got) {
			mmAddRequestsFromPrevExecutor.t.Errorf("BrokerIMock.AddRequestsFromPrevExecutor got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmAddRequestsFromPrevExecutor.funcAddRequestsFromPrevExecutor != nil {
		mmAddRequestsFromPrevExecutor.funcAddRequestsFromPrevExecutor(ctx, transcripts...)
		return
	}
	mmAddRequestsFromPrevExecutor.t.Fatalf("Unexpected call to BrokerIMock.AddRequestsFromPrevExecutor. %v %v", ctx, transcripts)

}

// AddRequestsFromPrevExecutorAfterCounter returns a count of finished BrokerIMock.AddRequestsFromPrevExecutor invocations
func (mmAddRequestsFromPrevExecutor *BrokerIMock) AddRequestsFromPrevExecutorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromPrevExecutor.afterAddRequestsFromPrevExecutorCounter)
}

// AddRequestsFromPrevExecutorBeforeCounter returns a count of BrokerIMock.AddRequestsFromPrevExecutor invocations
func (mmAddRequestsFromPrevExecutor *BrokerIMock) AddRequestsFromPrevExecutorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRequestsFromPrevExecutor.beforeAddRequestsFromPrevExecutorCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.AddRequestsFromPrevExecutor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRequestsFromPrevExecutor *mBrokerIMockAddRequestsFromPrevExecutor) Calls() []*BrokerIMockAddRequestsFromPrevExecutorParams {
	mmAddRequestsFromPrevExecutor.mutex.RLock()

	argCopy := make([]*BrokerIMockAddRequestsFromPrevExecutorParams, len(mmAddRequestsFromPrevExecutor.callArgs))
	copy(argCopy, mmAddRequestsFromPrevExecutor.callArgs)

	mmAddRequestsFromPrevExecutor.mutex.RUnlock()

	return argCopy
}

// MinimockAddRequestsFromPrevExecutorDone returns true if the count of the AddRequestsFromPrevExecutor invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockAddRequestsFromPrevExecutorDone() bool {
	for _, e := range m.AddRequestsFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddRequestsFromPrevExecutorInspect logs each unmet expectation
func (m *BrokerIMock) MinimockAddRequestsFromPrevExecutorInspect() {
	for _, e := range m.AddRequestsFromPrevExecutorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.AddRequestsFromPrevExecutor with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddRequestsFromPrevExecutorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		if m.AddRequestsFromPrevExecutorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.AddRequestsFromPrevExecutor")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.AddRequestsFromPrevExecutor with params: %#v", *m.AddRequestsFromPrevExecutorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRequestsFromPrevExecutor != nil && mm_atomic.LoadUint64(&m.afterAddRequestsFromPrevExecutorCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.AddRequestsFromPrevExecutor")
	}
}

type mBrokerIMockFetchMoreRequestsFromLedger struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockFetchMoreRequestsFromLedgerExpectation
	expectations       []*BrokerIMockFetchMoreRequestsFromLedgerExpectation

	callArgs []*BrokerIMockFetchMoreRequestsFromLedgerParams
	mutex    sync.RWMutex
}

// BrokerIMockFetchMoreRequestsFromLedgerExpectation specifies expectation struct of the BrokerI.FetchMoreRequestsFromLedger
type BrokerIMockFetchMoreRequestsFromLedgerExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockFetchMoreRequestsFromLedgerParams

	Counter uint64
}

// BrokerIMockFetchMoreRequestsFromLedgerParams contains parameters of the BrokerI.FetchMoreRequestsFromLedger
type BrokerIMockFetchMoreRequestsFromLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for BrokerI.FetchMoreRequestsFromLedger
func (mmFetchMoreRequestsFromLedger *mBrokerIMockFetchMoreRequestsFromLedger) Expect(ctx context.Context) *mBrokerIMockFetchMoreRequestsFromLedger {
	if mmFetchMoreRequestsFromLedger.mock.funcFetchMoreRequestsFromLedger != nil {
		mmFetchMoreRequestsFromLedger.mock.t.Fatalf("BrokerIMock.FetchMoreRequestsFromLedger mock is already set by Set")
	}

	if mmFetchMoreRequestsFromLedger.defaultExpectation == nil {
		mmFetchMoreRequestsFromLedger.defaultExpectation = &BrokerIMockFetchMoreRequestsFromLedgerExpectation{}
	}

	mmFetchMoreRequestsFromLedger.defaultExpectation.params = &BrokerIMockFetchMoreRequestsFromLedgerParams{ctx}
	for _, e := range mmFetchMoreRequestsFromLedger.expectations {
		if minimock.Equal(e.params, mmFetchMoreRequestsFromLedger.defaultExpectation.params) {
			mmFetchMoreRequestsFromLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchMoreRequestsFromLedger.defaultExpectation.params)
		}
	}

	return mmFetchMoreRequestsFromLedger
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.FetchMoreRequestsFromLedger
func (mmFetchMoreRequestsFromLedger *mBrokerIMockFetchMoreRequestsFromLedger) Inspect(f func(ctx context.Context)) *mBrokerIMockFetchMoreRequestsFromLedger {
	if mmFetchMoreRequestsFromLedger.mock.inspectFuncFetchMoreRequestsFromLedger != nil {
		mmFetchMoreRequestsFromLedger.mock.t.Fatalf("Inspect function is already set for BrokerIMock.FetchMoreRequestsFromLedger")
	}

	mmFetchMoreRequestsFromLedger.mock.inspectFuncFetchMoreRequestsFromLedger = f

	return mmFetchMoreRequestsFromLedger
}

// Return sets up results that will be returned by BrokerI.FetchMoreRequestsFromLedger
func (mmFetchMoreRequestsFromLedger *mBrokerIMockFetchMoreRequestsFromLedger) Return() *BrokerIMock {
	if mmFetchMoreRequestsFromLedger.mock.funcFetchMoreRequestsFromLedger != nil {
		mmFetchMoreRequestsFromLedger.mock.t.Fatalf("BrokerIMock.FetchMoreRequestsFromLedger mock is already set by Set")
	}

	if mmFetchMoreRequestsFromLedger.defaultExpectation == nil {
		mmFetchMoreRequestsFromLedger.defaultExpectation = &BrokerIMockFetchMoreRequestsFromLedgerExpectation{mock: mmFetchMoreRequestsFromLedger.mock}
	}

	return mmFetchMoreRequestsFromLedger.mock
}

//Set uses given function f to mock the BrokerI.FetchMoreRequestsFromLedger method
func (mmFetchMoreRequestsFromLedger *mBrokerIMockFetchMoreRequestsFromLedger) Set(f func(ctx context.Context)) *BrokerIMock {
	if mmFetchMoreRequestsFromLedger.defaultExpectation != nil {
		mmFetchMoreRequestsFromLedger.mock.t.Fatalf("Default expectation is already set for the BrokerI.FetchMoreRequestsFromLedger method")
	}

	if len(mmFetchMoreRequestsFromLedger.expectations) > 0 {
		mmFetchMoreRequestsFromLedger.mock.t.Fatalf("Some expectations are already set for the BrokerI.FetchMoreRequestsFromLedger method")
	}

	mmFetchMoreRequestsFromLedger.mock.funcFetchMoreRequestsFromLedger = f
	return mmFetchMoreRequestsFromLedger.mock
}

// FetchMoreRequestsFromLedger implements BrokerI
func (mmFetchMoreRequestsFromLedger *BrokerIMock) FetchMoreRequestsFromLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmFetchMoreRequestsFromLedger.beforeFetchMoreRequestsFromLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchMoreRequestsFromLedger.afterFetchMoreRequestsFromLedgerCounter, 1)

	if mmFetchMoreRequestsFromLedger.inspectFuncFetchMoreRequestsFromLedger != nil {
		mmFetchMoreRequestsFromLedger.inspectFuncFetchMoreRequestsFromLedger(ctx)
	}

	params := &BrokerIMockFetchMoreRequestsFromLedgerParams{ctx}

	// Record call args
	mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.mutex.Lock()
	mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.callArgs = append(mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.callArgs, params)
	mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.mutex.Unlock()

	for _, e := range mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.defaultExpectation.Counter, 1)
		want := mmFetchMoreRequestsFromLedger.FetchMoreRequestsFromLedgerMock.defaultExpectation.params
		got := BrokerIMockFetchMoreRequestsFromLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmFetchMoreRequestsFromLedger.t.Errorf("BrokerIMock.FetchMoreRequestsFromLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmFetchMoreRequestsFromLedger.funcFetchMoreRequestsFromLedger != nil {
		mmFetchMoreRequestsFromLedger.funcFetchMoreRequestsFromLedger(ctx)
		return
	}
	mmFetchMoreRequestsFromLedger.t.Fatalf("Unexpected call to BrokerIMock.FetchMoreRequestsFromLedger. %v", ctx)

}

// FetchMoreRequestsFromLedgerAfterCounter returns a count of finished BrokerIMock.FetchMoreRequestsFromLedger invocations
func (mmFetchMoreRequestsFromLedger *BrokerIMock) FetchMoreRequestsFromLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchMoreRequestsFromLedger.afterFetchMoreRequestsFromLedgerCounter)
}

// FetchMoreRequestsFromLedgerBeforeCounter returns a count of BrokerIMock.FetchMoreRequestsFromLedger invocations
func (mmFetchMoreRequestsFromLedger *BrokerIMock) FetchMoreRequestsFromLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchMoreRequestsFromLedger.beforeFetchMoreRequestsFromLedgerCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.FetchMoreRequestsFromLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchMoreRequestsFromLedger *mBrokerIMockFetchMoreRequestsFromLedger) Calls() []*BrokerIMockFetchMoreRequestsFromLedgerParams {
	mmFetchMoreRequestsFromLedger.mutex.RLock()

	argCopy := make([]*BrokerIMockFetchMoreRequestsFromLedgerParams, len(mmFetchMoreRequestsFromLedger.callArgs))
	copy(argCopy, mmFetchMoreRequestsFromLedger.callArgs)

	mmFetchMoreRequestsFromLedger.mutex.RUnlock()

	return argCopy
}

// MinimockFetchMoreRequestsFromLedgerDone returns true if the count of the FetchMoreRequestsFromLedger invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockFetchMoreRequestsFromLedgerDone() bool {
	for _, e := range m.FetchMoreRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchMoreRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchMoreRequestsFromLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchMoreRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterFetchMoreRequestsFromLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockFetchMoreRequestsFromLedgerInspect logs each unmet expectation
func (m *BrokerIMock) MinimockFetchMoreRequestsFromLedgerInspect() {
	for _, e := range m.FetchMoreRequestsFromLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.FetchMoreRequestsFromLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FetchMoreRequestsFromLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFetchMoreRequestsFromLedgerCounter) < 1 {
		if m.FetchMoreRequestsFromLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.FetchMoreRequestsFromLedger")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.FetchMoreRequestsFromLedger with params: %#v", *m.FetchMoreRequestsFromLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchMoreRequestsFromLedger != nil && mm_atomic.LoadUint64(&m.afterFetchMoreRequestsFromLedgerCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.FetchMoreRequestsFromLedger")
	}
}

type mBrokerIMockGetActiveTranscript struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockGetActiveTranscriptExpectation
	expectations       []*BrokerIMockGetActiveTranscriptExpectation

	callArgs []*BrokerIMockGetActiveTranscriptParams
	mutex    sync.RWMutex
}

// BrokerIMockGetActiveTranscriptExpectation specifies expectation struct of the BrokerI.GetActiveTranscript
type BrokerIMockGetActiveTranscriptExpectation struct {
	mock    *BrokerIMock
	params  *BrokerIMockGetActiveTranscriptParams
	results *BrokerIMockGetActiveTranscriptResults
	Counter uint64
}

// BrokerIMockGetActiveTranscriptParams contains parameters of the BrokerI.GetActiveTranscript
type BrokerIMockGetActiveTranscriptParams struct {
	req insolar.Reference
}

// BrokerIMockGetActiveTranscriptResults contains results of the BrokerI.GetActiveTranscript
type BrokerIMockGetActiveTranscriptResults struct {
	tp1 *transcript.Transcript
}

// Expect sets up expected params for BrokerI.GetActiveTranscript
func (mmGetActiveTranscript *mBrokerIMockGetActiveTranscript) Expect(req insolar.Reference) *mBrokerIMockGetActiveTranscript {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("BrokerIMock.GetActiveTranscript mock is already set by Set")
	}

	if mmGetActiveTranscript.defaultExpectation == nil {
		mmGetActiveTranscript.defaultExpectation = &BrokerIMockGetActiveTranscriptExpectation{}
	}

	mmGetActiveTranscript.defaultExpectation.params = &BrokerIMockGetActiveTranscriptParams{req}
	for _, e := range mmGetActiveTranscript.expectations {
		if minimock.Equal(e.params, mmGetActiveTranscript.defaultExpectation.params) {
			mmGetActiveTranscript.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetActiveTranscript.defaultExpectation.params)
		}
	}

	return mmGetActiveTranscript
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.GetActiveTranscript
func (mmGetActiveTranscript *mBrokerIMockGetActiveTranscript) Inspect(f func(req insolar.Reference)) *mBrokerIMockGetActiveTranscript {
	if mmGetActiveTranscript.mock.inspectFuncGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("Inspect function is already set for BrokerIMock.GetActiveTranscript")
	}

	mmGetActiveTranscript.mock.inspectFuncGetActiveTranscript = f

	return mmGetActiveTranscript
}

// Return sets up results that will be returned by BrokerI.GetActiveTranscript
func (mmGetActiveTranscript *mBrokerIMockGetActiveTranscript) Return(tp1 *transcript.Transcript) *BrokerIMock {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("BrokerIMock.GetActiveTranscript mock is already set by Set")
	}

	if mmGetActiveTranscript.defaultExpectation == nil {
		mmGetActiveTranscript.defaultExpectation = &BrokerIMockGetActiveTranscriptExpectation{mock: mmGetActiveTranscript.mock}
	}
	mmGetActiveTranscript.defaultExpectation.results = &BrokerIMockGetActiveTranscriptResults{tp1}
	return mmGetActiveTranscript.mock
}

//Set uses given function f to mock the BrokerI.GetActiveTranscript method
func (mmGetActiveTranscript *mBrokerIMockGetActiveTranscript) Set(f func(req insolar.Reference) (tp1 *transcript.Transcript)) *BrokerIMock {
	if mmGetActiveTranscript.defaultExpectation != nil {
		mmGetActiveTranscript.mock.t.Fatalf("Default expectation is already set for the BrokerI.GetActiveTranscript method")
	}

	if len(mmGetActiveTranscript.expectations) > 0 {
		mmGetActiveTranscript.mock.t.Fatalf("Some expectations are already set for the BrokerI.GetActiveTranscript method")
	}

	mmGetActiveTranscript.mock.funcGetActiveTranscript = f
	return mmGetActiveTranscript.mock
}

// When sets expectation for the BrokerI.GetActiveTranscript which will trigger the result defined by the following
// Then helper
func (mmGetActiveTranscript *mBrokerIMockGetActiveTranscript) When(req insolar.Reference) *BrokerIMockGetActiveTranscriptExpectation {
	if mmGetActiveTranscript.mock.funcGetActiveTranscript != nil {
		mmGetActiveTranscript.mock.t.Fatalf("BrokerIMock.GetActiveTranscript mock is already set by Set")
	}

	expectation := &BrokerIMockGetActiveTranscriptExpectation{
		mock:   mmGetActiveTranscript.mock,
		params: &BrokerIMockGetActiveTranscriptParams{req},
	}
	mmGetActiveTranscript.expectations = append(mmGetActiveTranscript.expectations, expectation)
	return expectation
}

// Then sets up BrokerI.GetActiveTranscript return parameters for the expectation previously defined by the When method
func (e *BrokerIMockGetActiveTranscriptExpectation) Then(tp1 *transcript.Transcript) *BrokerIMock {
	e.results = &BrokerIMockGetActiveTranscriptResults{tp1}
	return e.mock
}

// GetActiveTranscript implements BrokerI
func (mmGetActiveTranscript *BrokerIMock) GetActiveTranscript(req insolar.Reference) (tp1 *transcript.Transcript) {
	mm_atomic.AddUint64(&mmGetActiveTranscript.beforeGetActiveTranscriptCounter, 1)
	defer mm_atomic.AddUint64(&mmGetActiveTranscript.afterGetActiveTranscriptCounter, 1)

	if mmGetActiveTranscript.inspectFuncGetActiveTranscript != nil {
		mmGetActiveTranscript.inspectFuncGetActiveTranscript(req)
	}

	params := &BrokerIMockGetActiveTranscriptParams{req}

	// Record call args
	mmGetActiveTranscript.GetActiveTranscriptMock.mutex.Lock()
	mmGetActiveTranscript.GetActiveTranscriptMock.callArgs = append(mmGetActiveTranscript.GetActiveTranscriptMock.callArgs, params)
	mmGetActiveTranscript.GetActiveTranscriptMock.mutex.Unlock()

	for _, e := range mmGetActiveTranscript.GetActiveTranscriptMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1
		}
	}

	if mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.Counter, 1)
		want := mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.params
		got := BrokerIMockGetActiveTranscriptParams{req}
		if want != nil && !minimock.Equal(*want, got) {
			mmGetActiveTranscript.t.Errorf("BrokerIMock.GetActiveTranscript got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmGetActiveTranscript.GetActiveTranscriptMock.defaultExpectation.results
		if results == nil {
			mmGetActiveTranscript.t.Fatal("No results are set for the BrokerIMock.GetActiveTranscript")
		}
		return (*results).tp1
	}
	if mmGetActiveTranscript.funcGetActiveTranscript != nil {
		return mmGetActiveTranscript.funcGetActiveTranscript(req)
	}
	mmGetActiveTranscript.t.Fatalf("Unexpected call to BrokerIMock.GetActiveTranscript. %v", req)
	return
}

// GetActiveTranscriptAfterCounter returns a count of finished BrokerIMock.GetActiveTranscript invocations
func (mmGetActiveTranscript *BrokerIMock) GetActiveTranscriptAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveTranscript.afterGetActiveTranscriptCounter)
}

// GetActiveTranscriptBeforeCounter returns a count of BrokerIMock.GetActiveTranscript invocations
func (mmGetActiveTranscript *BrokerIMock) GetActiveTranscriptBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetActiveTranscript.beforeGetActiveTranscriptCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.GetActiveTranscript.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetActiveTranscript *mBrokerIMockGetActiveTranscript) Calls() []*BrokerIMockGetActiveTranscriptParams {
	mmGetActiveTranscript.mutex.RLock()

	argCopy := make([]*BrokerIMockGetActiveTranscriptParams, len(mmGetActiveTranscript.callArgs))
	copy(argCopy, mmGetActiveTranscript.callArgs)

	mmGetActiveTranscript.mutex.RUnlock()

	return argCopy
}

// MinimockGetActiveTranscriptDone returns true if the count of the GetActiveTranscript invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockGetActiveTranscriptDone() bool {
	for _, e := range m.GetActiveTranscriptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveTranscriptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveTranscript != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetActiveTranscriptInspect logs each unmet expectation
func (m *BrokerIMock) MinimockGetActiveTranscriptInspect() {
	for _, e := range m.GetActiveTranscriptMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.GetActiveTranscript with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetActiveTranscriptMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		if m.GetActiveTranscriptMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.GetActiveTranscript")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.GetActiveTranscript with params: %#v", *m.GetActiveTranscriptMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetActiveTranscript != nil && mm_atomic.LoadUint64(&m.afterGetActiveTranscriptCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.GetActiveTranscript")
	}
}

type mBrokerIMockIsKnownRequest struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockIsKnownRequestExpectation
	expectations       []*BrokerIMockIsKnownRequestExpectation

	callArgs []*BrokerIMockIsKnownRequestParams
	mutex    sync.RWMutex
}

// BrokerIMockIsKnownRequestExpectation specifies expectation struct of the BrokerI.IsKnownRequest
type BrokerIMockIsKnownRequestExpectation struct {
	mock    *BrokerIMock
	params  *BrokerIMockIsKnownRequestParams
	results *BrokerIMockIsKnownRequestResults
	Counter uint64
}

// BrokerIMockIsKnownRequestParams contains parameters of the BrokerI.IsKnownRequest
type BrokerIMockIsKnownRequestParams struct {
	ctx context.Context
	req insolar.Reference
}

// BrokerIMockIsKnownRequestResults contains results of the BrokerI.IsKnownRequest
type BrokerIMockIsKnownRequestResults struct {
	b1 bool
}

// Expect sets up expected params for BrokerI.IsKnownRequest
func (mmIsKnownRequest *mBrokerIMockIsKnownRequest) Expect(ctx context.Context, req insolar.Reference) *mBrokerIMockIsKnownRequest {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("BrokerIMock.IsKnownRequest mock is already set by Set")
	}

	if mmIsKnownRequest.defaultExpectation == nil {
		mmIsKnownRequest.defaultExpectation = &BrokerIMockIsKnownRequestExpectation{}
	}

	mmIsKnownRequest.defaultExpectation.params = &BrokerIMockIsKnownRequestParams{ctx, req}
	for _, e := range mmIsKnownRequest.expectations {
		if minimock.Equal(e.params, mmIsKnownRequest.defaultExpectation.params) {
			mmIsKnownRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsKnownRequest.defaultExpectation.params)
		}
	}

	return mmIsKnownRequest
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.IsKnownRequest
func (mmIsKnownRequest *mBrokerIMockIsKnownRequest) Inspect(f func(ctx context.Context, req insolar.Reference)) *mBrokerIMockIsKnownRequest {
	if mmIsKnownRequest.mock.inspectFuncIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("Inspect function is already set for BrokerIMock.IsKnownRequest")
	}

	mmIsKnownRequest.mock.inspectFuncIsKnownRequest = f

	return mmIsKnownRequest
}

// Return sets up results that will be returned by BrokerI.IsKnownRequest
func (mmIsKnownRequest *mBrokerIMockIsKnownRequest) Return(b1 bool) *BrokerIMock {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("BrokerIMock.IsKnownRequest mock is already set by Set")
	}

	if mmIsKnownRequest.defaultExpectation == nil {
		mmIsKnownRequest.defaultExpectation = &BrokerIMockIsKnownRequestExpectation{mock: mmIsKnownRequest.mock}
	}
	mmIsKnownRequest.defaultExpectation.results = &BrokerIMockIsKnownRequestResults{b1}
	return mmIsKnownRequest.mock
}

//Set uses given function f to mock the BrokerI.IsKnownRequest method
func (mmIsKnownRequest *mBrokerIMockIsKnownRequest) Set(f func(ctx context.Context, req insolar.Reference) (b1 bool)) *BrokerIMock {
	if mmIsKnownRequest.defaultExpectation != nil {
		mmIsKnownRequest.mock.t.Fatalf("Default expectation is already set for the BrokerI.IsKnownRequest method")
	}

	if len(mmIsKnownRequest.expectations) > 0 {
		mmIsKnownRequest.mock.t.Fatalf("Some expectations are already set for the BrokerI.IsKnownRequest method")
	}

	mmIsKnownRequest.mock.funcIsKnownRequest = f
	return mmIsKnownRequest.mock
}

// When sets expectation for the BrokerI.IsKnownRequest which will trigger the result defined by the following
// Then helper
func (mmIsKnownRequest *mBrokerIMockIsKnownRequest) When(ctx context.Context, req insolar.Reference) *BrokerIMockIsKnownRequestExpectation {
	if mmIsKnownRequest.mock.funcIsKnownRequest != nil {
		mmIsKnownRequest.mock.t.Fatalf("BrokerIMock.IsKnownRequest mock is already set by Set")
	}

	expectation := &BrokerIMockIsKnownRequestExpectation{
		mock:   mmIsKnownRequest.mock,
		params: &BrokerIMockIsKnownRequestParams{ctx, req},
	}
	mmIsKnownRequest.expectations = append(mmIsKnownRequest.expectations, expectation)
	return expectation
}

// Then sets up BrokerI.IsKnownRequest return parameters for the expectation previously defined by the When method
func (e *BrokerIMockIsKnownRequestExpectation) Then(b1 bool) *BrokerIMock {
	e.results = &BrokerIMockIsKnownRequestResults{b1}
	return e.mock
}

// IsKnownRequest implements BrokerI
func (mmIsKnownRequest *BrokerIMock) IsKnownRequest(ctx context.Context, req insolar.Reference) (b1 bool) {
	mm_atomic.AddUint64(&mmIsKnownRequest.beforeIsKnownRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmIsKnownRequest.afterIsKnownRequestCounter, 1)

	if mmIsKnownRequest.inspectFuncIsKnownRequest != nil {
		mmIsKnownRequest.inspectFuncIsKnownRequest(ctx, req)
	}

	params := &BrokerIMockIsKnownRequestParams{ctx, req}

	// Record call args
	mmIsKnownRequest.IsKnownRequestMock.mutex.Lock()
	mmIsKnownRequest.IsKnownRequestMock.callArgs = append(mmIsKnownRequest.IsKnownRequestMock.callArgs, params)
	mmIsKnownRequest.IsKnownRequestMock.mutex.Unlock()

	for _, e := range mmIsKnownRequest.IsKnownRequestMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsKnownRequest.IsKnownRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.Counter, 1)
		want := mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.params
		got := BrokerIMockIsKnownRequestParams{ctx, req}
		if want != nil && !minimock.Equal(*want, got) {
			mmIsKnownRequest.t.Errorf("BrokerIMock.IsKnownRequest got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmIsKnownRequest.IsKnownRequestMock.defaultExpectation.results
		if results == nil {
			mmIsKnownRequest.t.Fatal("No results are set for the BrokerIMock.IsKnownRequest")
		}
		return (*results).b1
	}
	if mmIsKnownRequest.funcIsKnownRequest != nil {
		return mmIsKnownRequest.funcIsKnownRequest(ctx, req)
	}
	mmIsKnownRequest.t.Fatalf("Unexpected call to BrokerIMock.IsKnownRequest. %v %v", ctx, req)
	return
}

// IsKnownRequestAfterCounter returns a count of finished BrokerIMock.IsKnownRequest invocations
func (mmIsKnownRequest *BrokerIMock) IsKnownRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKnownRequest.afterIsKnownRequestCounter)
}

// IsKnownRequestBeforeCounter returns a count of BrokerIMock.IsKnownRequest invocations
func (mmIsKnownRequest *BrokerIMock) IsKnownRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsKnownRequest.beforeIsKnownRequestCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.IsKnownRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsKnownRequest *mBrokerIMockIsKnownRequest) Calls() []*BrokerIMockIsKnownRequestParams {
	mmIsKnownRequest.mutex.RLock()

	argCopy := make([]*BrokerIMockIsKnownRequestParams, len(mmIsKnownRequest.callArgs))
	copy(argCopy, mmIsKnownRequest.callArgs)

	mmIsKnownRequest.mutex.RUnlock()

	return argCopy
}

// MinimockIsKnownRequestDone returns true if the count of the IsKnownRequest invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockIsKnownRequestDone() bool {
	for _, e := range m.IsKnownRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsKnownRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsKnownRequest != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsKnownRequestInspect logs each unmet expectation
func (m *BrokerIMock) MinimockIsKnownRequestInspect() {
	for _, e := range m.IsKnownRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.IsKnownRequest with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsKnownRequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		if m.IsKnownRequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.IsKnownRequest")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.IsKnownRequest with params: %#v", *m.IsKnownRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsKnownRequest != nil && mm_atomic.LoadUint64(&m.afterIsKnownRequestCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.IsKnownRequest")
	}
}

type mBrokerIMockMoreRequestsOnLedger struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockMoreRequestsOnLedgerExpectation
	expectations       []*BrokerIMockMoreRequestsOnLedgerExpectation

	callArgs []*BrokerIMockMoreRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// BrokerIMockMoreRequestsOnLedgerExpectation specifies expectation struct of the BrokerI.MoreRequestsOnLedger
type BrokerIMockMoreRequestsOnLedgerExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockMoreRequestsOnLedgerParams

	Counter uint64
}

// BrokerIMockMoreRequestsOnLedgerParams contains parameters of the BrokerI.MoreRequestsOnLedger
type BrokerIMockMoreRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for BrokerI.MoreRequestsOnLedger
func (mmMoreRequestsOnLedger *mBrokerIMockMoreRequestsOnLedger) Expect(ctx context.Context) *mBrokerIMockMoreRequestsOnLedger {
	if mmMoreRequestsOnLedger.mock.funcMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("BrokerIMock.MoreRequestsOnLedger mock is already set by Set")
	}

	if mmMoreRequestsOnLedger.defaultExpectation == nil {
		mmMoreRequestsOnLedger.defaultExpectation = &BrokerIMockMoreRequestsOnLedgerExpectation{}
	}

	mmMoreRequestsOnLedger.defaultExpectation.params = &BrokerIMockMoreRequestsOnLedgerParams{ctx}
	for _, e := range mmMoreRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmMoreRequestsOnLedger.defaultExpectation.params) {
			mmMoreRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMoreRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmMoreRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.MoreRequestsOnLedger
func (mmMoreRequestsOnLedger *mBrokerIMockMoreRequestsOnLedger) Inspect(f func(ctx context.Context)) *mBrokerIMockMoreRequestsOnLedger {
	if mmMoreRequestsOnLedger.mock.inspectFuncMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for BrokerIMock.MoreRequestsOnLedger")
	}

	mmMoreRequestsOnLedger.mock.inspectFuncMoreRequestsOnLedger = f

	return mmMoreRequestsOnLedger
}

// Return sets up results that will be returned by BrokerI.MoreRequestsOnLedger
func (mmMoreRequestsOnLedger *mBrokerIMockMoreRequestsOnLedger) Return() *BrokerIMock {
	if mmMoreRequestsOnLedger.mock.funcMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("BrokerIMock.MoreRequestsOnLedger mock is already set by Set")
	}

	if mmMoreRequestsOnLedger.defaultExpectation == nil {
		mmMoreRequestsOnLedger.defaultExpectation = &BrokerIMockMoreRequestsOnLedgerExpectation{mock: mmMoreRequestsOnLedger.mock}
	}

	return mmMoreRequestsOnLedger.mock
}

//Set uses given function f to mock the BrokerI.MoreRequestsOnLedger method
func (mmMoreRequestsOnLedger *mBrokerIMockMoreRequestsOnLedger) Set(f func(ctx context.Context)) *BrokerIMock {
	if mmMoreRequestsOnLedger.defaultExpectation != nil {
		mmMoreRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the BrokerI.MoreRequestsOnLedger method")
	}

	if len(mmMoreRequestsOnLedger.expectations) > 0 {
		mmMoreRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the BrokerI.MoreRequestsOnLedger method")
	}

	mmMoreRequestsOnLedger.mock.funcMoreRequestsOnLedger = f
	return mmMoreRequestsOnLedger.mock
}

// MoreRequestsOnLedger implements BrokerI
func (mmMoreRequestsOnLedger *BrokerIMock) MoreRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmMoreRequestsOnLedger.beforeMoreRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmMoreRequestsOnLedger.afterMoreRequestsOnLedgerCounter, 1)

	if mmMoreRequestsOnLedger.inspectFuncMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.inspectFuncMoreRequestsOnLedger(ctx)
	}

	params := &BrokerIMockMoreRequestsOnLedgerParams{ctx}

	// Record call args
	mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.mutex.Lock()
	mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.callArgs = append(mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.callArgs, params)
	mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		want := mmMoreRequestsOnLedger.MoreRequestsOnLedgerMock.defaultExpectation.params
		got := BrokerIMockMoreRequestsOnLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmMoreRequestsOnLedger.t.Errorf("BrokerIMock.MoreRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmMoreRequestsOnLedger.funcMoreRequestsOnLedger != nil {
		mmMoreRequestsOnLedger.funcMoreRequestsOnLedger(ctx)
		return
	}
	mmMoreRequestsOnLedger.t.Fatalf("Unexpected call to BrokerIMock.MoreRequestsOnLedger. %v", ctx)

}

// MoreRequestsOnLedgerAfterCounter returns a count of finished BrokerIMock.MoreRequestsOnLedger invocations
func (mmMoreRequestsOnLedger *BrokerIMock) MoreRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMoreRequestsOnLedger.afterMoreRequestsOnLedgerCounter)
}

// MoreRequestsOnLedgerBeforeCounter returns a count of BrokerIMock.MoreRequestsOnLedger invocations
func (mmMoreRequestsOnLedger *BrokerIMock) MoreRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMoreRequestsOnLedger.beforeMoreRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.MoreRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMoreRequestsOnLedger *mBrokerIMockMoreRequestsOnLedger) Calls() []*BrokerIMockMoreRequestsOnLedgerParams {
	mmMoreRequestsOnLedger.mutex.RLock()

	argCopy := make([]*BrokerIMockMoreRequestsOnLedgerParams, len(mmMoreRequestsOnLedger.callArgs))
	copy(argCopy, mmMoreRequestsOnLedger.callArgs)

	mmMoreRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockMoreRequestsOnLedgerDone returns true if the count of the MoreRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockMoreRequestsOnLedgerDone() bool {
	for _, e := range m.MoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockMoreRequestsOnLedgerInspect logs each unmet expectation
func (m *BrokerIMock) MinimockMoreRequestsOnLedgerInspect() {
	for _, e := range m.MoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.MoreRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		if m.MoreRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.MoreRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.MoreRequestsOnLedger with params: %#v", *m.MoreRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterMoreRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.MoreRequestsOnLedger")
	}
}

type mBrokerIMockNoMoreRequestsOnLedger struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockNoMoreRequestsOnLedgerExpectation
	expectations       []*BrokerIMockNoMoreRequestsOnLedgerExpectation

	callArgs []*BrokerIMockNoMoreRequestsOnLedgerParams
	mutex    sync.RWMutex
}

// BrokerIMockNoMoreRequestsOnLedgerExpectation specifies expectation struct of the BrokerI.NoMoreRequestsOnLedger
type BrokerIMockNoMoreRequestsOnLedgerExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockNoMoreRequestsOnLedgerParams

	Counter uint64
}

// BrokerIMockNoMoreRequestsOnLedgerParams contains parameters of the BrokerI.NoMoreRequestsOnLedger
type BrokerIMockNoMoreRequestsOnLedgerParams struct {
	ctx context.Context
}

// Expect sets up expected params for BrokerI.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mBrokerIMockNoMoreRequestsOnLedger) Expect(ctx context.Context) *mBrokerIMockNoMoreRequestsOnLedger {
	if mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("BrokerIMock.NoMoreRequestsOnLedger mock is already set by Set")
	}

	if mmNoMoreRequestsOnLedger.defaultExpectation == nil {
		mmNoMoreRequestsOnLedger.defaultExpectation = &BrokerIMockNoMoreRequestsOnLedgerExpectation{}
	}

	mmNoMoreRequestsOnLedger.defaultExpectation.params = &BrokerIMockNoMoreRequestsOnLedgerParams{ctx}
	for _, e := range mmNoMoreRequestsOnLedger.expectations {
		if minimock.Equal(e.params, mmNoMoreRequestsOnLedger.defaultExpectation.params) {
			mmNoMoreRequestsOnLedger.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNoMoreRequestsOnLedger.defaultExpectation.params)
		}
	}

	return mmNoMoreRequestsOnLedger
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mBrokerIMockNoMoreRequestsOnLedger) Inspect(f func(ctx context.Context)) *mBrokerIMockNoMoreRequestsOnLedger {
	if mmNoMoreRequestsOnLedger.mock.inspectFuncNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Inspect function is already set for BrokerIMock.NoMoreRequestsOnLedger")
	}

	mmNoMoreRequestsOnLedger.mock.inspectFuncNoMoreRequestsOnLedger = f

	return mmNoMoreRequestsOnLedger
}

// Return sets up results that will be returned by BrokerI.NoMoreRequestsOnLedger
func (mmNoMoreRequestsOnLedger *mBrokerIMockNoMoreRequestsOnLedger) Return() *BrokerIMock {
	if mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("BrokerIMock.NoMoreRequestsOnLedger mock is already set by Set")
	}

	if mmNoMoreRequestsOnLedger.defaultExpectation == nil {
		mmNoMoreRequestsOnLedger.defaultExpectation = &BrokerIMockNoMoreRequestsOnLedgerExpectation{mock: mmNoMoreRequestsOnLedger.mock}
	}

	return mmNoMoreRequestsOnLedger.mock
}

//Set uses given function f to mock the BrokerI.NoMoreRequestsOnLedger method
func (mmNoMoreRequestsOnLedger *mBrokerIMockNoMoreRequestsOnLedger) Set(f func(ctx context.Context)) *BrokerIMock {
	if mmNoMoreRequestsOnLedger.defaultExpectation != nil {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Default expectation is already set for the BrokerI.NoMoreRequestsOnLedger method")
	}

	if len(mmNoMoreRequestsOnLedger.expectations) > 0 {
		mmNoMoreRequestsOnLedger.mock.t.Fatalf("Some expectations are already set for the BrokerI.NoMoreRequestsOnLedger method")
	}

	mmNoMoreRequestsOnLedger.mock.funcNoMoreRequestsOnLedger = f
	return mmNoMoreRequestsOnLedger.mock
}

// NoMoreRequestsOnLedger implements BrokerI
func (mmNoMoreRequestsOnLedger *BrokerIMock) NoMoreRequestsOnLedger(ctx context.Context) {
	mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.beforeNoMoreRequestsOnLedgerCounter, 1)
	defer mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.afterNoMoreRequestsOnLedgerCounter, 1)

	if mmNoMoreRequestsOnLedger.inspectFuncNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.inspectFuncNoMoreRequestsOnLedger(ctx)
	}

	params := &BrokerIMockNoMoreRequestsOnLedgerParams{ctx}

	// Record call args
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.mutex.Lock()
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.callArgs = append(mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.callArgs, params)
	mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.mutex.Unlock()

	for _, e := range mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation.Counter, 1)
		want := mmNoMoreRequestsOnLedger.NoMoreRequestsOnLedgerMock.defaultExpectation.params
		got := BrokerIMockNoMoreRequestsOnLedgerParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmNoMoreRequestsOnLedger.t.Errorf("BrokerIMock.NoMoreRequestsOnLedger got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmNoMoreRequestsOnLedger.funcNoMoreRequestsOnLedger != nil {
		mmNoMoreRequestsOnLedger.funcNoMoreRequestsOnLedger(ctx)
		return
	}
	mmNoMoreRequestsOnLedger.t.Fatalf("Unexpected call to BrokerIMock.NoMoreRequestsOnLedger. %v", ctx)

}

// NoMoreRequestsOnLedgerAfterCounter returns a count of finished BrokerIMock.NoMoreRequestsOnLedger invocations
func (mmNoMoreRequestsOnLedger *BrokerIMock) NoMoreRequestsOnLedgerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNoMoreRequestsOnLedger.afterNoMoreRequestsOnLedgerCounter)
}

// NoMoreRequestsOnLedgerBeforeCounter returns a count of BrokerIMock.NoMoreRequestsOnLedger invocations
func (mmNoMoreRequestsOnLedger *BrokerIMock) NoMoreRequestsOnLedgerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNoMoreRequestsOnLedger.beforeNoMoreRequestsOnLedgerCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.NoMoreRequestsOnLedger.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNoMoreRequestsOnLedger *mBrokerIMockNoMoreRequestsOnLedger) Calls() []*BrokerIMockNoMoreRequestsOnLedgerParams {
	mmNoMoreRequestsOnLedger.mutex.RLock()

	argCopy := make([]*BrokerIMockNoMoreRequestsOnLedgerParams, len(mmNoMoreRequestsOnLedger.callArgs))
	copy(argCopy, mmNoMoreRequestsOnLedger.callArgs)

	mmNoMoreRequestsOnLedger.mutex.RUnlock()

	return argCopy
}

// MinimockNoMoreRequestsOnLedgerDone returns true if the count of the NoMoreRequestsOnLedger invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockNoMoreRequestsOnLedgerDone() bool {
	for _, e := range m.NoMoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NoMoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNoMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		return false
	}
	return true
}

// MinimockNoMoreRequestsOnLedgerInspect logs each unmet expectation
func (m *BrokerIMock) MinimockNoMoreRequestsOnLedgerInspect() {
	for _, e := range m.NoMoreRequestsOnLedgerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.NoMoreRequestsOnLedger with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NoMoreRequestsOnLedgerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		if m.NoMoreRequestsOnLedgerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.NoMoreRequestsOnLedger")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.NoMoreRequestsOnLedger with params: %#v", *m.NoMoreRequestsOnLedgerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNoMoreRequestsOnLedger != nil && mm_atomic.LoadUint64(&m.afterNoMoreRequestsOnLedgerCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.NoMoreRequestsOnLedger")
	}
}

type mBrokerIMockOnPulse struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockOnPulseExpectation
	expectations       []*BrokerIMockOnPulseExpectation

	callArgs []*BrokerIMockOnPulseParams
	mutex    sync.RWMutex
}

// BrokerIMockOnPulseExpectation specifies expectation struct of the BrokerI.OnPulse
type BrokerIMockOnPulseExpectation struct {
	mock    *BrokerIMock
	params  *BrokerIMockOnPulseParams
	results *BrokerIMockOnPulseResults
	Counter uint64
}

// BrokerIMockOnPulseParams contains parameters of the BrokerI.OnPulse
type BrokerIMockOnPulseParams struct {
	ctx    context.Context
	meNext bool
}

// BrokerIMockOnPulseResults contains results of the BrokerI.OnPulse
type BrokerIMockOnPulseResults struct {
	ma1 []insolar.Message
}

// Expect sets up expected params for BrokerI.OnPulse
func (mmOnPulse *mBrokerIMockOnPulse) Expect(ctx context.Context, meNext bool) *mBrokerIMockOnPulse {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("BrokerIMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &BrokerIMockOnPulseExpectation{}
	}

	mmOnPulse.defaultExpectation.params = &BrokerIMockOnPulseParams{ctx, meNext}
	for _, e := range mmOnPulse.expectations {
		if minimock.Equal(e.params, mmOnPulse.defaultExpectation.params) {
			mmOnPulse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOnPulse.defaultExpectation.params)
		}
	}

	return mmOnPulse
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.OnPulse
func (mmOnPulse *mBrokerIMockOnPulse) Inspect(f func(ctx context.Context, meNext bool)) *mBrokerIMockOnPulse {
	if mmOnPulse.mock.inspectFuncOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("Inspect function is already set for BrokerIMock.OnPulse")
	}

	mmOnPulse.mock.inspectFuncOnPulse = f

	return mmOnPulse
}

// Return sets up results that will be returned by BrokerI.OnPulse
func (mmOnPulse *mBrokerIMockOnPulse) Return(ma1 []insolar.Message) *BrokerIMock {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("BrokerIMock.OnPulse mock is already set by Set")
	}

	if mmOnPulse.defaultExpectation == nil {
		mmOnPulse.defaultExpectation = &BrokerIMockOnPulseExpectation{mock: mmOnPulse.mock}
	}
	mmOnPulse.defaultExpectation.results = &BrokerIMockOnPulseResults{ma1}
	return mmOnPulse.mock
}

//Set uses given function f to mock the BrokerI.OnPulse method
func (mmOnPulse *mBrokerIMockOnPulse) Set(f func(ctx context.Context, meNext bool) (ma1 []insolar.Message)) *BrokerIMock {
	if mmOnPulse.defaultExpectation != nil {
		mmOnPulse.mock.t.Fatalf("Default expectation is already set for the BrokerI.OnPulse method")
	}

	if len(mmOnPulse.expectations) > 0 {
		mmOnPulse.mock.t.Fatalf("Some expectations are already set for the BrokerI.OnPulse method")
	}

	mmOnPulse.mock.funcOnPulse = f
	return mmOnPulse.mock
}

// When sets expectation for the BrokerI.OnPulse which will trigger the result defined by the following
// Then helper
func (mmOnPulse *mBrokerIMockOnPulse) When(ctx context.Context, meNext bool) *BrokerIMockOnPulseExpectation {
	if mmOnPulse.mock.funcOnPulse != nil {
		mmOnPulse.mock.t.Fatalf("BrokerIMock.OnPulse mock is already set by Set")
	}

	expectation := &BrokerIMockOnPulseExpectation{
		mock:   mmOnPulse.mock,
		params: &BrokerIMockOnPulseParams{ctx, meNext},
	}
	mmOnPulse.expectations = append(mmOnPulse.expectations, expectation)
	return expectation
}

// Then sets up BrokerI.OnPulse return parameters for the expectation previously defined by the When method
func (e *BrokerIMockOnPulseExpectation) Then(ma1 []insolar.Message) *BrokerIMock {
	e.results = &BrokerIMockOnPulseResults{ma1}
	return e.mock
}

// OnPulse implements BrokerI
func (mmOnPulse *BrokerIMock) OnPulse(ctx context.Context, meNext bool) (ma1 []insolar.Message) {
	mm_atomic.AddUint64(&mmOnPulse.beforeOnPulseCounter, 1)
	defer mm_atomic.AddUint64(&mmOnPulse.afterOnPulseCounter, 1)

	if mmOnPulse.inspectFuncOnPulse != nil {
		mmOnPulse.inspectFuncOnPulse(ctx, meNext)
	}

	params := &BrokerIMockOnPulseParams{ctx, meNext}

	// Record call args
	mmOnPulse.OnPulseMock.mutex.Lock()
	mmOnPulse.OnPulseMock.callArgs = append(mmOnPulse.OnPulseMock.callArgs, params)
	mmOnPulse.OnPulseMock.mutex.Unlock()

	for _, e := range mmOnPulse.OnPulseMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1
		}
	}

	if mmOnPulse.OnPulseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOnPulse.OnPulseMock.defaultExpectation.Counter, 1)
		want := mmOnPulse.OnPulseMock.defaultExpectation.params
		got := BrokerIMockOnPulseParams{ctx, meNext}
		if want != nil && !minimock.Equal(*want, got) {
			mmOnPulse.t.Errorf("BrokerIMock.OnPulse got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOnPulse.OnPulseMock.defaultExpectation.results
		if results == nil {
			mmOnPulse.t.Fatal("No results are set for the BrokerIMock.OnPulse")
		}
		return (*results).ma1
	}
	if mmOnPulse.funcOnPulse != nil {
		return mmOnPulse.funcOnPulse(ctx, meNext)
	}
	mmOnPulse.t.Fatalf("Unexpected call to BrokerIMock.OnPulse. %v %v", ctx, meNext)
	return
}

// OnPulseAfterCounter returns a count of finished BrokerIMock.OnPulse invocations
func (mmOnPulse *BrokerIMock) OnPulseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.afterOnPulseCounter)
}

// OnPulseBeforeCounter returns a count of BrokerIMock.OnPulse invocations
func (mmOnPulse *BrokerIMock) OnPulseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOnPulse.beforeOnPulseCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.OnPulse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOnPulse *mBrokerIMockOnPulse) Calls() []*BrokerIMockOnPulseParams {
	mmOnPulse.mutex.RLock()

	argCopy := make([]*BrokerIMockOnPulseParams, len(mmOnPulse.callArgs))
	copy(argCopy, mmOnPulse.callArgs)

	mmOnPulse.mutex.RUnlock()

	return argCopy
}

// MinimockOnPulseDone returns true if the count of the OnPulse invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockOnPulseDone() bool {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		return false
	}
	return true
}

// MinimockOnPulseInspect logs each unmet expectation
func (m *BrokerIMock) MinimockOnPulseInspect() {
	for _, e := range m.OnPulseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.OnPulse with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OnPulseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		if m.OnPulseMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.OnPulse")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.OnPulse with params: %#v", *m.OnPulseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOnPulse != nil && mm_atomic.LoadUint64(&m.afterOnPulseCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.OnPulse")
	}
}

type mBrokerIMockPendingState struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockPendingStateExpectation
	expectations       []*BrokerIMockPendingStateExpectation
}

// BrokerIMockPendingStateExpectation specifies expectation struct of the BrokerI.PendingState
type BrokerIMockPendingStateExpectation struct {
	mock *BrokerIMock

	results *BrokerIMockPendingStateResults
	Counter uint64
}

// BrokerIMockPendingStateResults contains results of the BrokerI.PendingState
type BrokerIMockPendingStateResults struct {
	p1 insolar.PendingState
}

// Expect sets up expected params for BrokerI.PendingState
func (mmPendingState *mBrokerIMockPendingState) Expect() *mBrokerIMockPendingState {
	if mmPendingState.mock.funcPendingState != nil {
		mmPendingState.mock.t.Fatalf("BrokerIMock.PendingState mock is already set by Set")
	}

	if mmPendingState.defaultExpectation == nil {
		mmPendingState.defaultExpectation = &BrokerIMockPendingStateExpectation{}
	}

	return mmPendingState
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.PendingState
func (mmPendingState *mBrokerIMockPendingState) Inspect(f func()) *mBrokerIMockPendingState {
	if mmPendingState.mock.inspectFuncPendingState != nil {
		mmPendingState.mock.t.Fatalf("Inspect function is already set for BrokerIMock.PendingState")
	}

	mmPendingState.mock.inspectFuncPendingState = f

	return mmPendingState
}

// Return sets up results that will be returned by BrokerI.PendingState
func (mmPendingState *mBrokerIMockPendingState) Return(p1 insolar.PendingState) *BrokerIMock {
	if mmPendingState.mock.funcPendingState != nil {
		mmPendingState.mock.t.Fatalf("BrokerIMock.PendingState mock is already set by Set")
	}

	if mmPendingState.defaultExpectation == nil {
		mmPendingState.defaultExpectation = &BrokerIMockPendingStateExpectation{mock: mmPendingState.mock}
	}
	mmPendingState.defaultExpectation.results = &BrokerIMockPendingStateResults{p1}
	return mmPendingState.mock
}

//Set uses given function f to mock the BrokerI.PendingState method
func (mmPendingState *mBrokerIMockPendingState) Set(f func() (p1 insolar.PendingState)) *BrokerIMock {
	if mmPendingState.defaultExpectation != nil {
		mmPendingState.mock.t.Fatalf("Default expectation is already set for the BrokerI.PendingState method")
	}

	if len(mmPendingState.expectations) > 0 {
		mmPendingState.mock.t.Fatalf("Some expectations are already set for the BrokerI.PendingState method")
	}

	mmPendingState.mock.funcPendingState = f
	return mmPendingState.mock
}

// PendingState implements BrokerI
func (mmPendingState *BrokerIMock) PendingState() (p1 insolar.PendingState) {
	mm_atomic.AddUint64(&mmPendingState.beforePendingStateCounter, 1)
	defer mm_atomic.AddUint64(&mmPendingState.afterPendingStateCounter, 1)

	if mmPendingState.inspectFuncPendingState != nil {
		mmPendingState.inspectFuncPendingState()
	}

	if mmPendingState.PendingStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPendingState.PendingStateMock.defaultExpectation.Counter, 1)

		results := mmPendingState.PendingStateMock.defaultExpectation.results
		if results == nil {
			mmPendingState.t.Fatal("No results are set for the BrokerIMock.PendingState")
		}
		return (*results).p1
	}
	if mmPendingState.funcPendingState != nil {
		return mmPendingState.funcPendingState()
	}
	mmPendingState.t.Fatalf("Unexpected call to BrokerIMock.PendingState.")
	return
}

// PendingStateAfterCounter returns a count of finished BrokerIMock.PendingState invocations
func (mmPendingState *BrokerIMock) PendingStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPendingState.afterPendingStateCounter)
}

// PendingStateBeforeCounter returns a count of BrokerIMock.PendingState invocations
func (mmPendingState *BrokerIMock) PendingStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPendingState.beforePendingStateCounter)
}

// MinimockPendingStateDone returns true if the count of the PendingState invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockPendingStateDone() bool {
	for _, e := range m.PendingStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PendingStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPendingState != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		return false
	}
	return true
}

// MinimockPendingStateInspect logs each unmet expectation
func (m *BrokerIMock) MinimockPendingStateInspect() {
	for _, e := range m.PendingStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to BrokerIMock.PendingState")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PendingStateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.PendingState")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPendingState != nil && mm_atomic.LoadUint64(&m.afterPendingStateCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.PendingState")
	}
}

type mBrokerIMockPrevExecutorFinishedPending struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockPrevExecutorFinishedPendingExpectation
	expectations       []*BrokerIMockPrevExecutorFinishedPendingExpectation

	callArgs []*BrokerIMockPrevExecutorFinishedPendingParams
	mutex    sync.RWMutex
}

// BrokerIMockPrevExecutorFinishedPendingExpectation specifies expectation struct of the BrokerI.PrevExecutorFinishedPending
type BrokerIMockPrevExecutorFinishedPendingExpectation struct {
	mock    *BrokerIMock
	params  *BrokerIMockPrevExecutorFinishedPendingParams
	results *BrokerIMockPrevExecutorFinishedPendingResults
	Counter uint64
}

// BrokerIMockPrevExecutorFinishedPendingParams contains parameters of the BrokerI.PrevExecutorFinishedPending
type BrokerIMockPrevExecutorFinishedPendingParams struct {
	ctx context.Context
}

// BrokerIMockPrevExecutorFinishedPendingResults contains results of the BrokerI.PrevExecutorFinishedPending
type BrokerIMockPrevExecutorFinishedPendingResults struct {
	err error
}

// Expect sets up expected params for BrokerI.PrevExecutorFinishedPending
func (mmPrevExecutorFinishedPending *mBrokerIMockPrevExecutorFinishedPending) Expect(ctx context.Context) *mBrokerIMockPrevExecutorFinishedPending {
	if mmPrevExecutorFinishedPending.mock.funcPrevExecutorFinishedPending != nil {
		mmPrevExecutorFinishedPending.mock.t.Fatalf("BrokerIMock.PrevExecutorFinishedPending mock is already set by Set")
	}

	if mmPrevExecutorFinishedPending.defaultExpectation == nil {
		mmPrevExecutorFinishedPending.defaultExpectation = &BrokerIMockPrevExecutorFinishedPendingExpectation{}
	}

	mmPrevExecutorFinishedPending.defaultExpectation.params = &BrokerIMockPrevExecutorFinishedPendingParams{ctx}
	for _, e := range mmPrevExecutorFinishedPending.expectations {
		if minimock.Equal(e.params, mmPrevExecutorFinishedPending.defaultExpectation.params) {
			mmPrevExecutorFinishedPending.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorFinishedPending.defaultExpectation.params)
		}
	}

	return mmPrevExecutorFinishedPending
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.PrevExecutorFinishedPending
func (mmPrevExecutorFinishedPending *mBrokerIMockPrevExecutorFinishedPending) Inspect(f func(ctx context.Context)) *mBrokerIMockPrevExecutorFinishedPending {
	if mmPrevExecutorFinishedPending.mock.inspectFuncPrevExecutorFinishedPending != nil {
		mmPrevExecutorFinishedPending.mock.t.Fatalf("Inspect function is already set for BrokerIMock.PrevExecutorFinishedPending")
	}

	mmPrevExecutorFinishedPending.mock.inspectFuncPrevExecutorFinishedPending = f

	return mmPrevExecutorFinishedPending
}

// Return sets up results that will be returned by BrokerI.PrevExecutorFinishedPending
func (mmPrevExecutorFinishedPending *mBrokerIMockPrevExecutorFinishedPending) Return(err error) *BrokerIMock {
	if mmPrevExecutorFinishedPending.mock.funcPrevExecutorFinishedPending != nil {
		mmPrevExecutorFinishedPending.mock.t.Fatalf("BrokerIMock.PrevExecutorFinishedPending mock is already set by Set")
	}

	if mmPrevExecutorFinishedPending.defaultExpectation == nil {
		mmPrevExecutorFinishedPending.defaultExpectation = &BrokerIMockPrevExecutorFinishedPendingExpectation{mock: mmPrevExecutorFinishedPending.mock}
	}
	mmPrevExecutorFinishedPending.defaultExpectation.results = &BrokerIMockPrevExecutorFinishedPendingResults{err}
	return mmPrevExecutorFinishedPending.mock
}

//Set uses given function f to mock the BrokerI.PrevExecutorFinishedPending method
func (mmPrevExecutorFinishedPending *mBrokerIMockPrevExecutorFinishedPending) Set(f func(ctx context.Context) (err error)) *BrokerIMock {
	if mmPrevExecutorFinishedPending.defaultExpectation != nil {
		mmPrevExecutorFinishedPending.mock.t.Fatalf("Default expectation is already set for the BrokerI.PrevExecutorFinishedPending method")
	}

	if len(mmPrevExecutorFinishedPending.expectations) > 0 {
		mmPrevExecutorFinishedPending.mock.t.Fatalf("Some expectations are already set for the BrokerI.PrevExecutorFinishedPending method")
	}

	mmPrevExecutorFinishedPending.mock.funcPrevExecutorFinishedPending = f
	return mmPrevExecutorFinishedPending.mock
}

// When sets expectation for the BrokerI.PrevExecutorFinishedPending which will trigger the result defined by the following
// Then helper
func (mmPrevExecutorFinishedPending *mBrokerIMockPrevExecutorFinishedPending) When(ctx context.Context) *BrokerIMockPrevExecutorFinishedPendingExpectation {
	if mmPrevExecutorFinishedPending.mock.funcPrevExecutorFinishedPending != nil {
		mmPrevExecutorFinishedPending.mock.t.Fatalf("BrokerIMock.PrevExecutorFinishedPending mock is already set by Set")
	}

	expectation := &BrokerIMockPrevExecutorFinishedPendingExpectation{
		mock:   mmPrevExecutorFinishedPending.mock,
		params: &BrokerIMockPrevExecutorFinishedPendingParams{ctx},
	}
	mmPrevExecutorFinishedPending.expectations = append(mmPrevExecutorFinishedPending.expectations, expectation)
	return expectation
}

// Then sets up BrokerI.PrevExecutorFinishedPending return parameters for the expectation previously defined by the When method
func (e *BrokerIMockPrevExecutorFinishedPendingExpectation) Then(err error) *BrokerIMock {
	e.results = &BrokerIMockPrevExecutorFinishedPendingResults{err}
	return e.mock
}

// PrevExecutorFinishedPending implements BrokerI
func (mmPrevExecutorFinishedPending *BrokerIMock) PrevExecutorFinishedPending(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPrevExecutorFinishedPending.beforePrevExecutorFinishedPendingCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorFinishedPending.afterPrevExecutorFinishedPendingCounter, 1)

	if mmPrevExecutorFinishedPending.inspectFuncPrevExecutorFinishedPending != nil {
		mmPrevExecutorFinishedPending.inspectFuncPrevExecutorFinishedPending(ctx)
	}

	params := &BrokerIMockPrevExecutorFinishedPendingParams{ctx}

	// Record call args
	mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.mutex.Lock()
	mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.callArgs = append(mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.callArgs, params)
	mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.mutex.Unlock()

	for _, e := range mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.defaultExpectation.Counter, 1)
		want := mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.defaultExpectation.params
		got := BrokerIMockPrevExecutorFinishedPendingParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmPrevExecutorFinishedPending.t.Errorf("BrokerIMock.PrevExecutorFinishedPending got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmPrevExecutorFinishedPending.PrevExecutorFinishedPendingMock.defaultExpectation.results
		if results == nil {
			mmPrevExecutorFinishedPending.t.Fatal("No results are set for the BrokerIMock.PrevExecutorFinishedPending")
		}
		return (*results).err
	}
	if mmPrevExecutorFinishedPending.funcPrevExecutorFinishedPending != nil {
		return mmPrevExecutorFinishedPending.funcPrevExecutorFinishedPending(ctx)
	}
	mmPrevExecutorFinishedPending.t.Fatalf("Unexpected call to BrokerIMock.PrevExecutorFinishedPending. %v", ctx)
	return
}

// PrevExecutorFinishedPendingAfterCounter returns a count of finished BrokerIMock.PrevExecutorFinishedPending invocations
func (mmPrevExecutorFinishedPending *BrokerIMock) PrevExecutorFinishedPendingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorFinishedPending.afterPrevExecutorFinishedPendingCounter)
}

// PrevExecutorFinishedPendingBeforeCounter returns a count of BrokerIMock.PrevExecutorFinishedPending invocations
func (mmPrevExecutorFinishedPending *BrokerIMock) PrevExecutorFinishedPendingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorFinishedPending.beforePrevExecutorFinishedPendingCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.PrevExecutorFinishedPending.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorFinishedPending *mBrokerIMockPrevExecutorFinishedPending) Calls() []*BrokerIMockPrevExecutorFinishedPendingParams {
	mmPrevExecutorFinishedPending.mutex.RLock()

	argCopy := make([]*BrokerIMockPrevExecutorFinishedPendingParams, len(mmPrevExecutorFinishedPending.callArgs))
	copy(argCopy, mmPrevExecutorFinishedPending.callArgs)

	mmPrevExecutorFinishedPending.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorFinishedPendingDone returns true if the count of the PrevExecutorFinishedPending invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockPrevExecutorFinishedPendingDone() bool {
	for _, e := range m.PrevExecutorFinishedPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorFinishedPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorFinishedPendingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorFinishedPending != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorFinishedPendingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorFinishedPendingInspect logs each unmet expectation
func (m *BrokerIMock) MinimockPrevExecutorFinishedPendingInspect() {
	for _, e := range m.PrevExecutorFinishedPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.PrevExecutorFinishedPending with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorFinishedPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorFinishedPendingCounter) < 1 {
		if m.PrevExecutorFinishedPendingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.PrevExecutorFinishedPending")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.PrevExecutorFinishedPending with params: %#v", *m.PrevExecutorFinishedPendingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorFinishedPending != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorFinishedPendingCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.PrevExecutorFinishedPending")
	}
}

type mBrokerIMockPrevExecutorPendingResult struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockPrevExecutorPendingResultExpectation
	expectations       []*BrokerIMockPrevExecutorPendingResultExpectation

	callArgs []*BrokerIMockPrevExecutorPendingResultParams
	mutex    sync.RWMutex
}

// BrokerIMockPrevExecutorPendingResultExpectation specifies expectation struct of the BrokerI.PrevExecutorPendingResult
type BrokerIMockPrevExecutorPendingResultExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockPrevExecutorPendingResultParams

	Counter uint64
}

// BrokerIMockPrevExecutorPendingResultParams contains parameters of the BrokerI.PrevExecutorPendingResult
type BrokerIMockPrevExecutorPendingResultParams struct {
	ctx           context.Context
	prevExecState insolar.PendingState
}

// Expect sets up expected params for BrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mBrokerIMockPrevExecutorPendingResult) Expect(ctx context.Context, prevExecState insolar.PendingState) *mBrokerIMockPrevExecutorPendingResult {
	if mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("BrokerIMock.PrevExecutorPendingResult mock is already set by Set")
	}

	if mmPrevExecutorPendingResult.defaultExpectation == nil {
		mmPrevExecutorPendingResult.defaultExpectation = &BrokerIMockPrevExecutorPendingResultExpectation{}
	}

	mmPrevExecutorPendingResult.defaultExpectation.params = &BrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}
	for _, e := range mmPrevExecutorPendingResult.expectations {
		if minimock.Equal(e.params, mmPrevExecutorPendingResult.defaultExpectation.params) {
			mmPrevExecutorPendingResult.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorPendingResult.defaultExpectation.params)
		}
	}

	return mmPrevExecutorPendingResult
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mBrokerIMockPrevExecutorPendingResult) Inspect(f func(ctx context.Context, prevExecState insolar.PendingState)) *mBrokerIMockPrevExecutorPendingResult {
	if mmPrevExecutorPendingResult.mock.inspectFuncPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Inspect function is already set for BrokerIMock.PrevExecutorPendingResult")
	}

	mmPrevExecutorPendingResult.mock.inspectFuncPrevExecutorPendingResult = f

	return mmPrevExecutorPendingResult
}

// Return sets up results that will be returned by BrokerI.PrevExecutorPendingResult
func (mmPrevExecutorPendingResult *mBrokerIMockPrevExecutorPendingResult) Return() *BrokerIMock {
	if mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("BrokerIMock.PrevExecutorPendingResult mock is already set by Set")
	}

	if mmPrevExecutorPendingResult.defaultExpectation == nil {
		mmPrevExecutorPendingResult.defaultExpectation = &BrokerIMockPrevExecutorPendingResultExpectation{mock: mmPrevExecutorPendingResult.mock}
	}

	return mmPrevExecutorPendingResult.mock
}

//Set uses given function f to mock the BrokerI.PrevExecutorPendingResult method
func (mmPrevExecutorPendingResult *mBrokerIMockPrevExecutorPendingResult) Set(f func(ctx context.Context, prevExecState insolar.PendingState)) *BrokerIMock {
	if mmPrevExecutorPendingResult.defaultExpectation != nil {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Default expectation is already set for the BrokerI.PrevExecutorPendingResult method")
	}

	if len(mmPrevExecutorPendingResult.expectations) > 0 {
		mmPrevExecutorPendingResult.mock.t.Fatalf("Some expectations are already set for the BrokerI.PrevExecutorPendingResult method")
	}

	mmPrevExecutorPendingResult.mock.funcPrevExecutorPendingResult = f
	return mmPrevExecutorPendingResult.mock
}

// PrevExecutorPendingResult implements BrokerI
func (mmPrevExecutorPendingResult *BrokerIMock) PrevExecutorPendingResult(ctx context.Context, prevExecState insolar.PendingState) {
	mm_atomic.AddUint64(&mmPrevExecutorPendingResult.beforePrevExecutorPendingResultCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorPendingResult.afterPrevExecutorPendingResultCounter, 1)

	if mmPrevExecutorPendingResult.inspectFuncPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.inspectFuncPrevExecutorPendingResult(ctx, prevExecState)
	}

	params := &BrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}

	// Record call args
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.mutex.Lock()
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.callArgs = append(mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.callArgs, params)
	mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.mutex.Unlock()

	for _, e := range mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation.Counter, 1)
		want := mmPrevExecutorPendingResult.PrevExecutorPendingResultMock.defaultExpectation.params
		got := BrokerIMockPrevExecutorPendingResultParams{ctx, prevExecState}
		if want != nil && !minimock.Equal(*want, got) {
			mmPrevExecutorPendingResult.t.Errorf("BrokerIMock.PrevExecutorPendingResult got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPrevExecutorPendingResult.funcPrevExecutorPendingResult != nil {
		mmPrevExecutorPendingResult.funcPrevExecutorPendingResult(ctx, prevExecState)
		return
	}
	mmPrevExecutorPendingResult.t.Fatalf("Unexpected call to BrokerIMock.PrevExecutorPendingResult. %v %v", ctx, prevExecState)

}

// PrevExecutorPendingResultAfterCounter returns a count of finished BrokerIMock.PrevExecutorPendingResult invocations
func (mmPrevExecutorPendingResult *BrokerIMock) PrevExecutorPendingResultAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorPendingResult.afterPrevExecutorPendingResultCounter)
}

// PrevExecutorPendingResultBeforeCounter returns a count of BrokerIMock.PrevExecutorPendingResult invocations
func (mmPrevExecutorPendingResult *BrokerIMock) PrevExecutorPendingResultBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorPendingResult.beforePrevExecutorPendingResultCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.PrevExecutorPendingResult.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorPendingResult *mBrokerIMockPrevExecutorPendingResult) Calls() []*BrokerIMockPrevExecutorPendingResultParams {
	mmPrevExecutorPendingResult.mutex.RLock()

	argCopy := make([]*BrokerIMockPrevExecutorPendingResultParams, len(mmPrevExecutorPendingResult.callArgs))
	copy(argCopy, mmPrevExecutorPendingResult.callArgs)

	mmPrevExecutorPendingResult.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorPendingResultDone returns true if the count of the PrevExecutorPendingResult invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockPrevExecutorPendingResultDone() bool {
	for _, e := range m.PrevExecutorPendingResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorPendingResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorPendingResult != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorPendingResultInspect logs each unmet expectation
func (m *BrokerIMock) MinimockPrevExecutorPendingResultInspect() {
	for _, e := range m.PrevExecutorPendingResultMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.PrevExecutorPendingResult with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorPendingResultMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		if m.PrevExecutorPendingResultMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.PrevExecutorPendingResult")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.PrevExecutorPendingResult with params: %#v", *m.PrevExecutorPendingResultMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorPendingResult != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorPendingResultCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.PrevExecutorPendingResult")
	}
}

type mBrokerIMockPrevExecutorStillExecuting struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockPrevExecutorStillExecutingExpectation
	expectations       []*BrokerIMockPrevExecutorStillExecutingExpectation

	callArgs []*BrokerIMockPrevExecutorStillExecutingParams
	mutex    sync.RWMutex
}

// BrokerIMockPrevExecutorStillExecutingExpectation specifies expectation struct of the BrokerI.PrevExecutorStillExecuting
type BrokerIMockPrevExecutorStillExecutingExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockPrevExecutorStillExecutingParams

	Counter uint64
}

// BrokerIMockPrevExecutorStillExecutingParams contains parameters of the BrokerI.PrevExecutorStillExecuting
type BrokerIMockPrevExecutorStillExecutingParams struct {
	ctx context.Context
}

// Expect sets up expected params for BrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mBrokerIMockPrevExecutorStillExecuting) Expect(ctx context.Context) *mBrokerIMockPrevExecutorStillExecuting {
	if mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("BrokerIMock.PrevExecutorStillExecuting mock is already set by Set")
	}

	if mmPrevExecutorStillExecuting.defaultExpectation == nil {
		mmPrevExecutorStillExecuting.defaultExpectation = &BrokerIMockPrevExecutorStillExecutingExpectation{}
	}

	mmPrevExecutorStillExecuting.defaultExpectation.params = &BrokerIMockPrevExecutorStillExecutingParams{ctx}
	for _, e := range mmPrevExecutorStillExecuting.expectations {
		if minimock.Equal(e.params, mmPrevExecutorStillExecuting.defaultExpectation.params) {
			mmPrevExecutorStillExecuting.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevExecutorStillExecuting.defaultExpectation.params)
		}
	}

	return mmPrevExecutorStillExecuting
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mBrokerIMockPrevExecutorStillExecuting) Inspect(f func(ctx context.Context)) *mBrokerIMockPrevExecutorStillExecuting {
	if mmPrevExecutorStillExecuting.mock.inspectFuncPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Inspect function is already set for BrokerIMock.PrevExecutorStillExecuting")
	}

	mmPrevExecutorStillExecuting.mock.inspectFuncPrevExecutorStillExecuting = f

	return mmPrevExecutorStillExecuting
}

// Return sets up results that will be returned by BrokerI.PrevExecutorStillExecuting
func (mmPrevExecutorStillExecuting *mBrokerIMockPrevExecutorStillExecuting) Return() *BrokerIMock {
	if mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("BrokerIMock.PrevExecutorStillExecuting mock is already set by Set")
	}

	if mmPrevExecutorStillExecuting.defaultExpectation == nil {
		mmPrevExecutorStillExecuting.defaultExpectation = &BrokerIMockPrevExecutorStillExecutingExpectation{mock: mmPrevExecutorStillExecuting.mock}
	}

	return mmPrevExecutorStillExecuting.mock
}

//Set uses given function f to mock the BrokerI.PrevExecutorStillExecuting method
func (mmPrevExecutorStillExecuting *mBrokerIMockPrevExecutorStillExecuting) Set(f func(ctx context.Context)) *BrokerIMock {
	if mmPrevExecutorStillExecuting.defaultExpectation != nil {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Default expectation is already set for the BrokerI.PrevExecutorStillExecuting method")
	}

	if len(mmPrevExecutorStillExecuting.expectations) > 0 {
		mmPrevExecutorStillExecuting.mock.t.Fatalf("Some expectations are already set for the BrokerI.PrevExecutorStillExecuting method")
	}

	mmPrevExecutorStillExecuting.mock.funcPrevExecutorStillExecuting = f
	return mmPrevExecutorStillExecuting.mock
}

// PrevExecutorStillExecuting implements BrokerI
func (mmPrevExecutorStillExecuting *BrokerIMock) PrevExecutorStillExecuting(ctx context.Context) {
	mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.beforePrevExecutorStillExecutingCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.afterPrevExecutorStillExecutingCounter, 1)

	if mmPrevExecutorStillExecuting.inspectFuncPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.inspectFuncPrevExecutorStillExecuting(ctx)
	}

	params := &BrokerIMockPrevExecutorStillExecutingParams{ctx}

	// Record call args
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.mutex.Lock()
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.callArgs = append(mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.callArgs, params)
	mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.mutex.Unlock()

	for _, e := range mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation.Counter, 1)
		want := mmPrevExecutorStillExecuting.PrevExecutorStillExecutingMock.defaultExpectation.params
		got := BrokerIMockPrevExecutorStillExecutingParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmPrevExecutorStillExecuting.t.Errorf("BrokerIMock.PrevExecutorStillExecuting got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmPrevExecutorStillExecuting.funcPrevExecutorStillExecuting != nil {
		mmPrevExecutorStillExecuting.funcPrevExecutorStillExecuting(ctx)
		return
	}
	mmPrevExecutorStillExecuting.t.Fatalf("Unexpected call to BrokerIMock.PrevExecutorStillExecuting. %v", ctx)

}

// PrevExecutorStillExecutingAfterCounter returns a count of finished BrokerIMock.PrevExecutorStillExecuting invocations
func (mmPrevExecutorStillExecuting *BrokerIMock) PrevExecutorStillExecutingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorStillExecuting.afterPrevExecutorStillExecutingCounter)
}

// PrevExecutorStillExecutingBeforeCounter returns a count of BrokerIMock.PrevExecutorStillExecuting invocations
func (mmPrevExecutorStillExecuting *BrokerIMock) PrevExecutorStillExecutingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevExecutorStillExecuting.beforePrevExecutorStillExecutingCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.PrevExecutorStillExecuting.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevExecutorStillExecuting *mBrokerIMockPrevExecutorStillExecuting) Calls() []*BrokerIMockPrevExecutorStillExecutingParams {
	mmPrevExecutorStillExecuting.mutex.RLock()

	argCopy := make([]*BrokerIMockPrevExecutorStillExecutingParams, len(mmPrevExecutorStillExecuting.callArgs))
	copy(argCopy, mmPrevExecutorStillExecuting.callArgs)

	mmPrevExecutorStillExecuting.mutex.RUnlock()

	return argCopy
}

// MinimockPrevExecutorStillExecutingDone returns true if the count of the PrevExecutorStillExecuting invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockPrevExecutorStillExecutingDone() bool {
	for _, e := range m.PrevExecutorStillExecutingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorStillExecutingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorStillExecuting != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrevExecutorStillExecutingInspect logs each unmet expectation
func (m *BrokerIMock) MinimockPrevExecutorStillExecutingInspect() {
	for _, e := range m.PrevExecutorStillExecutingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.PrevExecutorStillExecuting with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrevExecutorStillExecutingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		if m.PrevExecutorStillExecutingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.PrevExecutorStillExecuting")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.PrevExecutorStillExecuting with params: %#v", *m.PrevExecutorStillExecutingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevExecutorStillExecuting != nil && mm_atomic.LoadUint64(&m.afterPrevExecutorStillExecutingCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.PrevExecutorStillExecuting")
	}
}

type mBrokerIMockSetNotPending struct {
	mock               *BrokerIMock
	defaultExpectation *BrokerIMockSetNotPendingExpectation
	expectations       []*BrokerIMockSetNotPendingExpectation

	callArgs []*BrokerIMockSetNotPendingParams
	mutex    sync.RWMutex
}

// BrokerIMockSetNotPendingExpectation specifies expectation struct of the BrokerI.SetNotPending
type BrokerIMockSetNotPendingExpectation struct {
	mock   *BrokerIMock
	params *BrokerIMockSetNotPendingParams

	Counter uint64
}

// BrokerIMockSetNotPendingParams contains parameters of the BrokerI.SetNotPending
type BrokerIMockSetNotPendingParams struct {
	ctx context.Context
}

// Expect sets up expected params for BrokerI.SetNotPending
func (mmSetNotPending *mBrokerIMockSetNotPending) Expect(ctx context.Context) *mBrokerIMockSetNotPending {
	if mmSetNotPending.mock.funcSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("BrokerIMock.SetNotPending mock is already set by Set")
	}

	if mmSetNotPending.defaultExpectation == nil {
		mmSetNotPending.defaultExpectation = &BrokerIMockSetNotPendingExpectation{}
	}

	mmSetNotPending.defaultExpectation.params = &BrokerIMockSetNotPendingParams{ctx}
	for _, e := range mmSetNotPending.expectations {
		if minimock.Equal(e.params, mmSetNotPending.defaultExpectation.params) {
			mmSetNotPending.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetNotPending.defaultExpectation.params)
		}
	}

	return mmSetNotPending
}

// Inspect accepts an inspector function that has same arguments as the BrokerI.SetNotPending
func (mmSetNotPending *mBrokerIMockSetNotPending) Inspect(f func(ctx context.Context)) *mBrokerIMockSetNotPending {
	if mmSetNotPending.mock.inspectFuncSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("Inspect function is already set for BrokerIMock.SetNotPending")
	}

	mmSetNotPending.mock.inspectFuncSetNotPending = f

	return mmSetNotPending
}

// Return sets up results that will be returned by BrokerI.SetNotPending
func (mmSetNotPending *mBrokerIMockSetNotPending) Return() *BrokerIMock {
	if mmSetNotPending.mock.funcSetNotPending != nil {
		mmSetNotPending.mock.t.Fatalf("BrokerIMock.SetNotPending mock is already set by Set")
	}

	if mmSetNotPending.defaultExpectation == nil {
		mmSetNotPending.defaultExpectation = &BrokerIMockSetNotPendingExpectation{mock: mmSetNotPending.mock}
	}

	return mmSetNotPending.mock
}

//Set uses given function f to mock the BrokerI.SetNotPending method
func (mmSetNotPending *mBrokerIMockSetNotPending) Set(f func(ctx context.Context)) *BrokerIMock {
	if mmSetNotPending.defaultExpectation != nil {
		mmSetNotPending.mock.t.Fatalf("Default expectation is already set for the BrokerI.SetNotPending method")
	}

	if len(mmSetNotPending.expectations) > 0 {
		mmSetNotPending.mock.t.Fatalf("Some expectations are already set for the BrokerI.SetNotPending method")
	}

	mmSetNotPending.mock.funcSetNotPending = f
	return mmSetNotPending.mock
}

// SetNotPending implements BrokerI
func (mmSetNotPending *BrokerIMock) SetNotPending(ctx context.Context) {
	mm_atomic.AddUint64(&mmSetNotPending.beforeSetNotPendingCounter, 1)
	defer mm_atomic.AddUint64(&mmSetNotPending.afterSetNotPendingCounter, 1)

	if mmSetNotPending.inspectFuncSetNotPending != nil {
		mmSetNotPending.inspectFuncSetNotPending(ctx)
	}

	params := &BrokerIMockSetNotPendingParams{ctx}

	// Record call args
	mmSetNotPending.SetNotPendingMock.mutex.Lock()
	mmSetNotPending.SetNotPendingMock.callArgs = append(mmSetNotPending.SetNotPendingMock.callArgs, params)
	mmSetNotPending.SetNotPendingMock.mutex.Unlock()

	for _, e := range mmSetNotPending.SetNotPendingMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetNotPending.SetNotPendingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetNotPending.SetNotPendingMock.defaultExpectation.Counter, 1)
		want := mmSetNotPending.SetNotPendingMock.defaultExpectation.params
		got := BrokerIMockSetNotPendingParams{ctx}
		if want != nil && !minimock.Equal(*want, got) {
			mmSetNotPending.t.Errorf("BrokerIMock.SetNotPending got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		return

	}
	if mmSetNotPending.funcSetNotPending != nil {
		mmSetNotPending.funcSetNotPending(ctx)
		return
	}
	mmSetNotPending.t.Fatalf("Unexpected call to BrokerIMock.SetNotPending. %v", ctx)

}

// SetNotPendingAfterCounter returns a count of finished BrokerIMock.SetNotPending invocations
func (mmSetNotPending *BrokerIMock) SetNotPendingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNotPending.afterSetNotPendingCounter)
}

// SetNotPendingBeforeCounter returns a count of BrokerIMock.SetNotPending invocations
func (mmSetNotPending *BrokerIMock) SetNotPendingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNotPending.beforeSetNotPendingCounter)
}

// Calls returns a list of arguments used in each call to BrokerIMock.SetNotPending.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetNotPending *mBrokerIMockSetNotPending) Calls() []*BrokerIMockSetNotPendingParams {
	mmSetNotPending.mutex.RLock()

	argCopy := make([]*BrokerIMockSetNotPendingParams, len(mmSetNotPending.callArgs))
	copy(argCopy, mmSetNotPending.callArgs)

	mmSetNotPending.mutex.RUnlock()

	return argCopy
}

// MinimockSetNotPendingDone returns true if the count of the SetNotPending invocations corresponds
// the number of defined expectations
func (m *BrokerIMock) MinimockSetNotPendingDone() bool {
	for _, e := range m.SetNotPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNotPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNotPending != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetNotPendingInspect logs each unmet expectation
func (m *BrokerIMock) MinimockSetNotPendingInspect() {
	for _, e := range m.SetNotPendingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BrokerIMock.SetNotPending with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetNotPendingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		if m.SetNotPendingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BrokerIMock.SetNotPending")
		} else {
			m.t.Errorf("Expected call to BrokerIMock.SetNotPending with params: %#v", *m.SetNotPendingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNotPending != nil && mm_atomic.LoadUint64(&m.afterSetNotPendingCounter) < 1 {
		m.t.Error("Expected call to BrokerIMock.SetNotPending")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BrokerIMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAbandonedRequestsOnLedgerInspect()

		m.MinimockAddAdditionalRequestFromPrevExecutorInspect()

		m.MinimockAddFreshRequestInspect()

		m.MinimockAddRequestsFromLedgerInspect()

		m.MinimockAddRequestsFromPrevExecutorInspect()

		m.MinimockFetchMoreRequestsFromLedgerInspect()

		m.MinimockGetActiveTranscriptInspect()

		m.MinimockIsKnownRequestInspect()

		m.MinimockMoreRequestsOnLedgerInspect()

		m.MinimockNoMoreRequestsOnLedgerInspect()

		m.MinimockOnPulseInspect()

		m.MinimockPendingStateInspect()

		m.MinimockPrevExecutorFinishedPendingInspect()

		m.MinimockPrevExecutorPendingResultInspect()

		m.MinimockPrevExecutorStillExecutingInspect()

		m.MinimockSetNotPendingInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BrokerIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BrokerIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAbandonedRequestsOnLedgerDone() &&
		m.MinimockAddAdditionalRequestFromPrevExecutorDone() &&
		m.MinimockAddFreshRequestDone() &&
		m.MinimockAddRequestsFromLedgerDone() &&
		m.MinimockAddRequestsFromPrevExecutorDone() &&
		m.MinimockFetchMoreRequestsFromLedgerDone() &&
		m.MinimockGetActiveTranscriptDone() &&
		m.MinimockIsKnownRequestDone() &&
		m.MinimockMoreRequestsOnLedgerDone() &&
		m.MinimockNoMoreRequestsOnLedgerDone() &&
		m.MinimockOnPulseDone() &&
		m.MinimockPendingStateDone() &&
		m.MinimockPrevExecutorFinishedPendingDone() &&
		m.MinimockPrevExecutorPendingResultDone() &&
		m.MinimockPrevExecutorStillExecutingDone() &&
		m.MinimockSetNotPendingDone()
}
